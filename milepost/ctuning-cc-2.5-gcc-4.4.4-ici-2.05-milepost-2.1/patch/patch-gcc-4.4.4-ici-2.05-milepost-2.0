diff -crBN ../gcc-4.4.4/configure gcc-4.4.4/configure
*** ../gcc-4.4.4/configure	2009-04-25 06:10:29.000000000 +0200
--- gcc-4.4.4/configure	2010-05-05 23:12:10.000000000 +0200
***************
*** 6338,6343 ****
--- 6338,6353 ----
      ;;
  esac
  
+ # Plugin-specific flags
+ case "${target}" in
+   *-*-darwin*)
+     FLAGS_FOR_TARGET="$FLAGS_FOR_TARGET -dynamic -ldl"
+     ;;
+   *)
+     FLAGS_FOR_TARGET="$FLAGS_FOR_TARGET -export-dynamic -ldl"
+     ;;
+ esac
+ 
  # Makefile fragments.
  for frag in host_makefile_frag target_makefile_frag alphaieee_frag ospace_frag;
  do
diff -crBN ../gcc-4.4.4/configure.ac gcc-4.4.4/configure.ac
*** ../gcc-4.4.4/configure.ac	2009-04-25 06:10:29.000000000 +0200
--- gcc-4.4.4/configure.ac	2010-05-05 23:12:10.000000000 +0200
***************
*** 2639,2644 ****
--- 2639,2654 ----
      ;;
  esac
  
+ # Plugin-specific flags
+ case "${target}" in
+   *-*-darwin*)
+     FLAGS_FOR_TARGET="$FLAGS_FOR_TARGET -dynamic -ldl"
+     ;;
+   *)
+     FLAGS_FOR_TARGET="$FLAGS_FOR_TARGET -export-dynamic -ldl"
+     ;;
+ esac
+ 
  # Makefile fragments.
  for frag in host_makefile_frag target_makefile_frag alphaieee_frag ospace_frag;
  do
diff -crBN ../gcc-4.4.4/gcc/cfgrtl.c gcc-4.4.4/gcc/cfgrtl.c
*** ../gcc-4.4.4/gcc/cfgrtl.c	2010-03-08 12:46:28.000000000 +0100
--- gcc-4.4.4/gcc/cfgrtl.c	2010-05-05 23:12:10.000000000 +0200
***************
*** 446,452 ****
  {
   {
    RTL_PASS,
!   NULL,                                 /* name */
    NULL,                                 /* gate */
    rest_of_pass_free_cfg,                /* execute */
    NULL,                                 /* sub */
--- 446,452 ----
  {
   {
    RTL_PASS,
!   "free_cfg",                           /* name */
    NULL,                                 /* gate */
    rest_of_pass_free_cfg,                /* execute */
    NULL,                                 /* sub */
diff -crBN ../gcc-4.4.4/gcc/cgraphbuild.c gcc-4.4.4/gcc/cgraphbuild.c
*** ../gcc-4.4.4/gcc/cgraphbuild.c	2008-12-06 09:34:20.000000000 +0100
--- gcc-4.4.4/gcc/cgraphbuild.c	2010-05-05 23:12:10.000000000 +0200
***************
*** 202,208 ****
  {
   {
    GIMPLE_PASS,
!   NULL,					/* name */
    NULL,					/* gate */
    build_cgraph_edges,			/* execute */
    NULL,					/* sub */
--- 202,208 ----
  {
   {
    GIMPLE_PASS,
!   "build_cgraph_edges",			/* name */
    NULL,					/* gate */
    build_cgraph_edges,			/* execute */
    NULL,					/* sub */
***************
*** 263,269 ****
  {
   {
    GIMPLE_PASS,
!   NULL,					/* name */
    NULL,					/* gate */
    rebuild_cgraph_edges,			/* execute */
    NULL,					/* sub */
--- 263,269 ----
  {
   {
    GIMPLE_PASS,
!   "rebuild_cgraph_edges",		/* name */
    NULL,					/* gate */
    rebuild_cgraph_edges,			/* execute */
    NULL,					/* sub */
diff -crBN ../gcc-4.4.4/gcc/common.opt gcc-4.4.4/gcc/common.opt
*** ../gcc-4.4.4/gcc/common.opt	2009-03-28 18:28:45.000000000 +0100
--- gcc-4.4.4/gcc/common.opt	2010-05-05 23:12:10.000000000 +0200
***************
*** 573,578 ****
--- 573,582 ----
  Common Report Var(flag_guess_branch_prob) Optimization
  Enable guessing of branch probabilities
  
+ fici
+ Common Report Var(flag_ici) 
+ Enables Interactive Compilation Interface
+ 
  ; Nonzero means ignore `#ident' directives.  0 means handle them.
  ; Generate position-independent code for executables if possible
  ; On SVR4 targets, it also controls whether or not to emit a
diff -crBN ../gcc-4.4.4/gcc/dce.c gcc-4.4.4/gcc/dce.c
*** ../gcc-4.4.4/gcc/dce.c	2009-01-16 14:41:11.000000000 +0100
--- gcc-4.4.4/gcc/dce.c	2010-05-05 23:12:10.000000000 +0200
***************
*** 738,746 ****
  {
   {
    RTL_PASS,
!   "dce",                                /* name */
!   gate_ud_dce,                        /* gate */
!   rest_of_handle_ud_dce,              /* execute */
    NULL,                                 /* sub */
    NULL,                                 /* next */
    0,                                    /* static_pass_number */
--- 738,746 ----
  {
   {
    RTL_PASS,
!   "ud_rtl_dce",                         /* name */
!   gate_ud_dce,                          /* gate */
!   rest_of_handle_ud_dce,                /* execute */
    NULL,                                 /* sub */
    NULL,                                 /* next */
    0,                                    /* static_pass_number */
***************
*** 1123,1129 ****
  {
   {
    RTL_PASS,
!   "dce",                                /* name */
    gate_fast_dce,                        /* gate */
    rest_of_handle_fast_dce,              /* execute */
    NULL,                                 /* sub */
--- 1123,1129 ----
  {
   {
    RTL_PASS,
!   "fast_rtl_dce",                       /* name */
    gate_fast_dce,                        /* gate */
    rest_of_handle_fast_dce,              /* execute */
    NULL,                                 /* sub */
diff -crBN ../gcc-4.4.4/gcc/df-core.c gcc-4.4.4/gcc/df-core.c
*** ../gcc-4.4.4/gcc/df-core.c	2008-12-06 23:52:43.000000000 +0100
--- gcc-4.4.4/gcc/df-core.c	2010-05-05 23:12:10.000000000 +0200
***************
*** 787,793 ****
  {
   {
    RTL_PASS,
!   "dfinit",                             /* name */
    gate_no_opt,                          /* gate */
    rest_of_handle_df_initialize,         /* execute */
    NULL,                                 /* sub */
--- 787,793 ----
  {
   {
    RTL_PASS,
!   "dfinit_no_opt",                      /* name */
    gate_no_opt,                          /* gate */
    rest_of_handle_df_initialize,         /* execute */
    NULL,                                 /* sub */
diff -crBN ../gcc-4.4.4/gcc/events.c gcc-4.4.4/gcc/events.c
*** ../gcc-4.4.4/gcc/events.c	1970-01-01 01:00:00.000000000 +0100
--- gcc-4.4.4/gcc/events.c	2010-05-05 23:12:10.000000000 +0200
***************
*** 0 ****
--- 1,294 ----
+ /* High-level event callback mechanism for GCC plugins.
+    Copyright (C) 2009 Free Software Foundation, Inc.
+    
+    Contributed by Inria.
+ 
+    Authors: Grigori Fursin <gfursin@gmail.com>, Cupertino Miranda
+    <cupertinomiranda@gmail.com>, Zbigniew Chamski <zbigniew.chamski@gmail.com>.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify it under
+ the terms of the GNU General Public License as published by the Free
+ Software Foundation; either version 3, or (at your option) any later
+ version.
+ 
+ GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+ WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING3.  If not see
+ <http://www.gnu.org/licenses/>.  */
+ 
+ #include "config.h"
+ #include "system.h"
+ #include "coretypes.h"
+ #include "hashtab.h"
+ #include "toplev.h"
+ #include "errors.h"
+ 
+ #include "highlev-plugin-internal.h"
+ 
+ /* Event structure.  */
+ struct plugin_event {
+   const char *name;		/* Name for the event */
+   event_callback_t run;		/* Callback function */
+ };
+ 
+ 
+ /* Parameter structure.  */
+ struct event_parameter {
+   const char *name;		/* Name for the parameter */
+   void *value;			/* Pointer to data */
+ };
+ 
+ 
+ static htab_t events_hash = NULL; 
+ static htab_t parameters_hash = NULL; 
+ 
+ 
+ /* Hash dependent functions.  */
+ static hashval_t
+ string_htab_hash (const void *x)
+ {
+   const char *p = *((const char * const *) x);
+ 
+   if (p != NULL)
+     return htab_hash_string (p);
+ 
+   return 0;
+ }
+ 
+ 
+ static int
+ string_htab_eq (const void *x, const void *y)
+ {
+   const char *s1 = *((const char * const *) x);
+   const char *s2 = *((const char * const *) y);
+ 
+   return !strcmp (s1, s2);
+ }
+ 
+ 
+ static void
+ parameter_htab_del (void *p)
+ {
+   struct parameter *param = (struct parameter *) p;
+   free (param);
+ }
+ 
+ 
+ /* Register a new event into hash table.  */
+ void 
+ register_plugin_event (const char *event_name, event_callback_t func)
+ {
+   void **slot;
+   struct plugin_event *ev = XCNEW (struct plugin_event);
+ 
+   ev->name = event_name;
+   ev->run = func;
+ 
+   if (ev->name == NULL)
+     internal_error ("Event cannot be registered with NULL name string\n");
+ 
+   if (events_hash == NULL)
+     events_hash = htab_create_alloc (150, string_htab_hash, 
+ 				     string_htab_eq, NULL, xcalloc, free);
+ 
+   if (events_hash != NULL)
+     {
+       slot = htab_find_slot (events_hash, ev, INSERT);
+       *slot = (void *) ev;
+     }
+ }
+ 
+ 
+ /* Used in GCC code to throw an event.
+  * If event is currently defined, its callback (if any) is executed.
+  * Return values:
+  *   PLUGEVT_SUCCESS (== 0) if at least one event callback was executed,
+  *   PLUGEVT_NO_EVENTS if no events whatsoever have been defined so far,
+  *   PLUGEVT_NO_SUCH_EVENT if the event was not found,
+  *   PLUGEVT_NO_CALLBACK if the callback list was empty. */
+ int
+ call_plugin_event (const char *event_name)
+ {
+   struct plugin_event tmp_event;
+   struct plugin_event *ev;
+ 
+   tmp_event.name = event_name;
+ 
+   /* no event hash means no events defined */
+   if (events_hash == NULL) return PLUGEVT_NO_EVENTS;
+ 
+   ev = (struct plugin_event *) htab_find (events_hash, &tmp_event);
+ 
+   /* report the event-not-found condition */
+   if (!ev) return PLUGEVT_NO_SUCH_EVENT;
+ 
+   /* report the absence of callbacks */
+   if (ev->run == NULL) return PLUGEVT_NO_CALLBACK;
+ 
+   /* If all is OK, run the callback */
+   ev->run ();
+   return PLUGEVT_SUCCESS;
+ }
+ 
+ 
+ /* Get list of names of all registered events.
+  * Traverse the hash table collecting the names of entries.
+  */
+ static int
+ add_event_name (void **slot, void *data)
+ {
+   const char ***crnt_name_ptr = (const char ***) data;
+   struct plugin_event *event = *(struct plugin_event **) slot;
+ 
+   /* store the name of the current event at the corresponding
+      location */
+   **crnt_name_ptr = event->name;
+ 
+   /* advance the current location */
+   (*crnt_name_ptr)++;
+ 
+   /* return "OK" */
+   return 1;
+ }
+ 
+ /* return the array of all event names, terminated by NULL */
+ const char **
+ list_plugin_events (void)
+ {
+   size_t num_events = htab_elements (events_hash);
+ 
+   /* allocate space for all names + the terminating NULL */
+   const char **all_events = (const char **)
+     xmalloc (sizeof (const char *) * (num_events + 1));
+ 
+   const char ***data = &all_events; /* data ptr for mapped function */
+   const char **first_event = all_events; /* keep track of actual start */
+ 
+   /* mark end-of-array */
+   all_events[num_events] = NULL;
+ 
+   /* collect all event names */
+   htab_traverse_noresize (events_hash, add_event_name, data);
+ 
+   /* use the stored start-of-array - all_events has changed during
+      htab_traverse_noresize */
+   return first_event;  
+ }
+ 
+ 
+ /* Register parameter.
+  * Insert parameter into hash table. Allocates hash table
+  * if needed.  */
+ void 
+ register_event_parameter (const char *name, void* value)
+ {
+   void **slot;
+   struct event_parameter *param = XCNEW (struct event_parameter);
+ 
+   param->name = name;
+   param->value = value;
+ 
+   if (param->name == NULL || !strcmp ("", param->name))
+     internal_error ("Parameter cannot be registered with NULL name string\n");
+   
+   if (parameters_hash == NULL)
+     parameters_hash =
+       htab_create_alloc (150, string_htab_hash, 
+ 			 string_htab_eq, parameter_htab_del, xcalloc, free);
+   
+   if (parameters_hash != NULL)
+     {
+       slot = htab_find_slot (parameters_hash, param, INSERT);
+       *slot = (void *) param;
+     }
+ }
+ 
+ 
+ /* Unregister parameter. Remove it from hash table.  */
+ void 
+ unregister_event_parameter (const char *name)
+ {
+   struct event_parameter param;
+   param.name = name;
+ 
+   if (parameters_hash == NULL)
+     internal_error ("Parameter hash not initialized.\n");
+ 
+   if (parameters_hash != NULL)
+     htab_remove_elt (parameters_hash, &param);
+ }
+ 
+ 
+ /* Get parameter pointer to data.
+  * Used by plugin to get pointer to data of the parameter <name>.  */
+ void *
+ get_event_parameter (const char *name)
+ {
+   struct event_parameter tmp_param, *param;
+   tmp_param.name = name;
+ 
+   if (parameters_hash == NULL)
+     internal_error ("Parameter hash not initialized.\n");
+   
+   if (parameters_hash != NULL)
+     {
+       param = (struct event_parameter *)
+ 	htab_find (parameters_hash, &tmp_param);
+       
+       if (param != NULL && param->value != NULL)
+ 	return param->value;
+     }
+   return NULL;
+ }
+ 
+ 
+ /* Get list of names of all registered ICI parameters.
+  * Traverse the hash table collecting the names of entries.
+  */
+ static int
+ add_parameter_name (void **slot, void *data)
+ {
+   const char ***crnt_name_ptr = (const char ***) data;
+   struct event_parameter *parameter = *(struct event_parameter **) slot;
+ 
+   /* store the name of the current parameter at the corresponding
+      location */
+   **crnt_name_ptr = parameter->name;
+ 
+   /* advance the current location */
+   (*crnt_name_ptr)++;
+ 
+   /* return "OK" */
+   return 1;
+ }
+ 
+ 
+ /* return the array of all parameter names, terminated by NULL */
+ const char **
+ list_event_parameters (void)
+ {
+   size_t num_parameters = htab_elements (parameters_hash);
+ 
+   /* allocate space for all names + the terminating NULL */
+   const char **all_parameters = (const char **)
+     xmalloc (sizeof (const char *) * (num_parameters+1));
+ 
+   const char ***data = &all_parameters; /* data ptr for mapped function */
+   const char **first_parameter = all_parameters; /* keep track of actual start */
+ 
+   /* mark end-of-array */
+   all_parameters[num_parameters] = NULL;
+ 
+   /* collect all parameter names */
+   htab_traverse_noresize (parameters_hash, add_parameter_name, data);
+ 
+   /* use the stored start-of-array - all_parameters has changed during
+      htab_traverse_noresize */
+   return first_parameter;  
+ }
diff -crBN ../gcc-4.4.4/gcc/except.c gcc-4.4.4/gcc/except.c
*** ../gcc-4.4.4/gcc/except.c	2010-03-08 12:46:28.000000000 +0100
--- gcc-4.4.4/gcc/except.c	2010-05-05 23:12:10.000000000 +0200
***************
*** 2817,2823 ****
  {
   {
    RTL_PASS,
!   NULL,                                 /* name */
    NULL,                                 /* gate */
    set_nothrow_function_flags,           /* execute */
    NULL,                                 /* sub */
--- 2817,2823 ----
  {
   {
    RTL_PASS,
!   "set_nothrow_function_flags",         /* name */
    NULL,                                 /* gate */
    set_nothrow_function_flags,           /* execute */
    NULL,                                 /* sub */
***************
*** 3964,3970 ****
  {
   {
    RTL_PASS,
!   "eh",                                 /* name */
    gate_handle_eh,                       /* gate */
    rest_of_handle_eh,			/* execute */
    NULL,                                 /* sub */
--- 3964,3970 ----
  {
   {
    RTL_PASS,
!   "rtl_eh",                                 /* name */
    gate_handle_eh,                       /* gate */
    rest_of_handle_eh,			/* execute */
    NULL,                                 /* sub */
diff -crBN ../gcc-4.4.4/gcc/feature.c gcc-4.4.4/gcc/feature.c
*** ../gcc-4.4.4/gcc/feature.c	1970-01-01 01:00:00.000000000 +0100
--- gcc-4.4.4/gcc/feature.c	2010-05-05 23:12:10.000000000 +0200
***************
*** 0 ****
--- 1,210 ----
+ /* Features: a high-level mechanism for accessing global compiler state in GCC.
+    Copyright (C) 2009 Free Software Foundation, Inc.
+    
+    Contributed by Inria.
+ 
+    Authors: Grigori Fursin <gfursin@gmail.com>, Cupertino Miranda
+    <cupertinomiranda@gmail.com>, Zbigniew Chamski <zbigniew.chamski@gmail.com>.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify it under
+ the terms of the GNU General Public License as published by the Free
+ Software Foundation; either version 3, or (at your option) any later
+ version.
+ 
+ GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+ WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING3.  If not see
+ <http://www.gnu.org/licenses/>.  */
+ 
+ #include "config.h"
+ #include "system.h"
+ #include "coretypes.h"
+ #include "hashtab.h"
+ #include "toplev.h"
+ 
+ #include "feature-internal.h"
+ 
+ htab_t features_hash = NULL; 
+ 
+ 
+ /* Hash dependent functions.  */
+ 
+ static hashval_t
+ features_htab_hash (const void *x)
+ {
+   const struct feature *p = (const struct feature *) x;
+   
+   if (!p)
+     internal_error ("features_htab_hash: called with NULL feature pointer!");
+   
+   if (p->name != NULL)
+     return htab_hash_string(p->name);
+   else
+     internal_error ("features_htab_hash: NULL-named feature!\n");
+ }
+ 
+ 
+ static int
+ features_htab_eq (const void *x, const void *y)
+ {
+   const struct feature *p1 = (const struct feature *) x;
+   const struct feature *p2 = (const struct feature *) y;
+ 
+   return !strcmp (p1->name, p2->name);
+ }
+ 
+ 
+ /* Add feature to hash table.  */
+ void register_feature (const struct feature *feature)
+ {
+   void const **slot;
+ 
+   if (!feature)
+     internal_error ("register_feature() called with NULL feature!\n");
+ 
+   if (feature->name == NULL)
+     internal_error ("register_feature() called with NULL-named feature!\n");
+ 
+   if(features_hash == NULL)
+     features_hash = htab_create_alloc (150, features_htab_hash, 
+ 				       features_htab_eq, NULL, xcalloc, free);
+ 
+   if(features_hash != NULL)
+     {
+       slot = (const void **) htab_find_slot (features_hash, feature, INSERT);
+       *slot = (const void *) feature;
+     }
+ }
+ 
+ 
+ /* FICI0: ici_find_feature: find the feature with a given name.
+  * Return values:
+  *  - pointer to 'struct feature' if the named feature was found;
+  *  - NULL if the feature could not be found.
+  */
+ struct feature *find_feature (const char *feature_name)
+ {
+   struct feature tmp_feature;
+ 
+   tmp_feature.name = feature_name;
+ 
+   return (struct feature *) htab_find (features_hash, &tmp_feature);
+ }
+ 
+ 
+ /* Get pointer to feature with <feature_name>.  */
+ const void *get_feature (const char *feature_name)
+ {
+   const struct feature *feature;
+ 
+   feature = find_feature (feature_name);
+ 
+   if(feature == NULL)
+     return NULL;
+ 
+   if(feature->data != NULL)
+     return (const void *) feature->data;
+   else if (feature->callback != NULL)
+     /* Call only non-NULL callbacks */
+     return feature->callback ();
+   else
+     return NULL;
+ }
+ 
+ 
+ /* Return the size of the data associated with feature */
+ int get_feature_size (const char *feature_name)
+ {
+   const struct feature *feature;
+   
+   feature = find_feature (feature_name);
+   
+   if(feature == NULL)
+     return -1;
+ 
+   return feature->data_size;
+ }
+ 
+ 
+ /* FICI0: get specific sub-feature of a main feature.
+  * Prerequisites: both feature and subfeature must exist (no diagnostics).
+  * Return values:
+  *  - string subfeatures: pointer-to-char corresponding to the string;
+  *  - integer/boolean/bit subfeatures: integer converted to pointer-to-void.
+  */
+ const void *
+ get_subfeature (const char *feature_name, const char *subfeat_name)
+ {
+   const struct feature *feature;
+   
+   feature = find_feature (feature_name);
+ 
+   /* no feature or no subfeature callback: bail out. */
+   if (!feature || !feature->get_subfeature)
+     return NULL;
+ 
+   return (feature->get_subfeature (subfeat_name));
+ }
+ 
+ 
+ /* FICI0: set sub-feature */
+ void *set_subfeature (const char *feature_name,
+ 			  const char *subfeat_name,
+ 			  void *subfeat_value)
+ {
+   struct feature *feature = find_feature (feature_name);
+ 
+   /* no feature or no subfeature callback: bail out. */
+   if (!feature || !feature->set_subfeature) return NULL;
+ 
+   return feature->set_subfeature (subfeat_name, subfeat_value); 
+ }
+ 
+ 
+ static int
+ add_feature_name (void **slot, void *data)
+ {
+   const char ***crnt_name_ptr = (const char ***) data;
+   struct feature *feature = *(struct feature **) slot;
+ 
+   /* store the name of the current fearute at the corresponding
+      location */
+   **crnt_name_ptr = feature->name;
+   
+   /* advance the current location */
+   (*crnt_name_ptr)++;
+ 
+   /* return "OK" */
+   return 1;
+ }
+ 
+ 
+ /* return the array of all feature names, terminated by NULL */
+ const char **
+ list_features (void)
+ {
+   size_t num_features = htab_elements (features_hash);
+ 
+   /* allocate space for all names + the terminating NULL */
+   const char **all_features = (const char **)
+     xmalloc (sizeof (const char *) * (num_features+1));
+   
+   const char ***data = &all_features; /* data ptr for mapped function */
+   const char **first_feature = all_features; /* keep track of actual start */
+ 
+   /* mark end-of-array */
+   all_features[num_features] = NULL;
+ 
+   /* collect all feature names */
+   htab_traverse_noresize (features_hash, add_feature_name, data);
+ 
+   /* use the stored start-of-array - all_features has changed during
+      htab_traverse_noresize */
+   return first_feature;  
+ }
diff -crBN ../gcc-4.4.4/gcc/feature.h gcc-4.4.4/gcc/feature.h
*** ../gcc-4.4.4/gcc/feature.h	1970-01-01 01:00:00.000000000 +0100
--- gcc-4.4.4/gcc/feature.h	2010-05-05 23:12:10.000000000 +0200
***************
*** 0 ****
--- 1,44 ----
+ /* Plugin-side interface to global compiler state for GCC plugins.
+    Copyright (C) 2009 Free Software Foundation, Inc.
+    
+    Contributed by Inria.
+ 
+    Authors: Grigori Fursin <gfursin@gmail.com>, Cupertino Miranda
+    <cupertinomiranda@gmail.com>, Zbigniew Chamski <zbigniew.chamski@gmail.com>.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify it under
+ the terms of the GNU General Public License as published by the Free
+ Software Foundation; either version 3, or (at your option) any later
+ version.
+ 
+ GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+ WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING3.  If not see
+ <http://www.gnu.org/licenses/>.  */
+ 
+ #ifndef FEATURE_H
+ #define FEATURE_H
+ 
+ /* Access to values of either features or elements of feature sets */
+ extern const void *get_feature (const char *feature_name);
+ extern const void *get_subfeature (const char *feature_name,
+ 				   const char *subfeat_name);
+ extern void *set_subfeature (const char *feature_name,
+ 			     const char *subfeat_name, void *value);
+ 
+ /* Extract the size of features and feature sets */
+ extern int get_feature_size (const char *feature_name);
+ extern int get_num_features (int type);
+ extern int get_num_subfeatures (const char *feat_name, int type);
+ 
+ /* List of all known features, or all known elements of a feature set */
+ extern const char **list_features (void);
+ extern const char **list_subfeatures (const char *feat_name, int type);
+ 
+ #endif /* FEATURE_H */
diff -crBN ../gcc-4.4.4/gcc/feature-internal.h gcc-4.4.4/gcc/feature-internal.h
*** ../gcc-4.4.4/gcc/feature-internal.h	1970-01-01 01:00:00.000000000 +0100
--- gcc-4.4.4/gcc/feature-internal.h	2010-05-05 23:12:10.000000000 +0200
***************
*** 0 ****
--- 1,65 ----
+ /* Compiler-side interface to global compiler state for GCC plugins.
+    Copyright (C) 2009 Free Software Foundation, Inc.
+    
+    Contributed by Inria.
+ 
+    Authors: Grigori Fursin <gfursin@gmail.com>, Cupertino Miranda
+    <cupertinomiranda@gmail.com>, Zbigniew Chamski <zbigniew.chamski@gmail.com>.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify it under
+ the terms of the GNU General Public License as published by the Free
+ Software Foundation; either version 3, or (at your option) any later
+ version.
+ 
+ GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+ WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING3.  If not see
+ <http://www.gnu.org/licenses/>.  */
+ 
+ #ifndef FEATURE_INTERNAL_H
+ #define FEATURE_INTERNAL_H
+ 
+ /* Compiler feature: a well-defined compiler property (config or state
+    information) that can be modified at runtime in a limited and controlled
+    fashion. */
+ struct feature {
+   const char *name;           /* Feature name */
+   void *data;                 /* Data for a static/memoized feature */
+   long int data_size;	      /* size of the data - for copying etc. */
+   const void * (*callback) (void);  /* Callback to dynamically extract
+ 				       feature value */
+   const void * (*get_subfeature) (const char *name);
+   			      /* callback to dynamically get values of
+ 				 subfeatures */
+   void * (*set_subfeature) (const char *name, void *value);
+  			      /* callback to set values of subfeatures */
+ };
+ 
+ /* Manipulation of feature directory (table) */
+ extern void register_feature (const struct feature *feature);
+ extern struct feature *find_feature (const char *feature_name);
+ extern void init_features (void);
+ 
+ /* Access to values of either features or elements of feature sets */
+ extern const void *get_feature (const char *feature_name);
+ extern const void *get_subfeature (const char *feature_name,
+ 				   const char *subfeat_name);
+ extern void *set_subfeature (const char *feature_name,
+ 			     const char *subfeat_name, void *value);
+ 
+ /* Extract the size of features and feature sets */
+ extern int get_feature_size (const char *feature_name);
+ extern int get_num_features (int type);
+ extern int get_num_subfeatures (const char *feat_name, int type);
+ 
+ /* List of all known features, or all known elements of a feature set */
+ extern const char **list_features (void);
+ extern const char **list_subfeatures (const char *feat_name, int type);
+ 
+ #endif /* FEATURE_INTERNAL_H */
diff -crBN ../gcc-4.4.4/gcc/feature-list.c gcc-4.4.4/gcc/feature-list.c
*** ../gcc-4.4.4/gcc/feature-list.c	1970-01-01 01:00:00.000000000 +0100
--- gcc-4.4.4/gcc/feature-list.c	2010-05-05 23:12:10.000000000 +0200
***************
*** 0 ****
--- 1,520 ----
+ /* High-level access points to global compiler state in GCC.
+    Copyright (C) 2009 Free Software Foundation, Inc.
+ 
+    Contributed by Inria.
+ 
+    Authors: Grigori Fursin <gfursin@gmail.com>, Cupertino Miranda
+    <cupertinomiranda@gmail.com>, Zbigniew Chamski <zbigniew.chamski@gmail.com>.
+ 
+    Updated by Joern Rennecke to get mangled function names instead of real names
+    to support C++ in MILEPOST GCC.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify it under
+ the terms of the GNU General Public License as published by the Free
+ Software Foundation; either version 3, or (at your option) any later
+ version.
+ 
+ GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+ WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING3.  If not see
+ <http://www.gnu.org/licenses/>.  */
+ 
+ #include "feature-internal.h"
+ 
+ #include "config.h"
+ #include "system.h"
+ 
+ #include "coretypes.h"
+ #include "tm.h"
+ #include "line-map.h"
+ #include "input.h"
+ #include "tree.h"
+ #include "basic-block.h"
+ #include "tree-inline.h"
+ #include "tree-flow.h"
+ #include "tree-pass.h"
+ 
+ #include "version.h"
+ #include "opts.h"
+ #include "params.h"
+ #include "function.h"
+ #include "input.h"
+ 
+ /* FORNOW: ZC: make declarations from "passes.c" visible here */
+ /* A map from static pass dump id to optimization pass.  */
+ extern struct opt_pass **passes_by_id;
+ extern int passes_by_id_size;
+ 
+ 
+ /* FICI0: "function_name": get name of current function if the
+    current function is defined, and return NULL otherwise.  */
+ static const void *function_name (void)
+ {
+   if (cfun)
+ /* Joern changed this to support C++ in MILEPOST GCC
+     return (const void *) current_function_name(); */
+     return (const void *) current_function_assembler_name ();
+   else
+     return NULL;
+ }
+ 
+ const struct feature feature_function_name = {
+   "function_name",                /* name */
+   NULL,                           /* data */
+   0,				  /* no data */
+   &function_name,                 /* callback */
+   NULL,				  /* no get subfeature callback */
+   NULL				  /* no set subfeature callback */
+ };
+ 
+ /* FICI0: "first_pass": get name of the first pass of the compiler */
+ struct opt_pass *_pass_parents[] = { NULL, NULL, NULL, NULL, NULL, 
+ 					 NULL, NULL, NULL, NULL, NULL}; 
+ int _pass_parents_count = 0; 
+ struct opt_pass *_current_pass = NULL;
+ 
+ static const void *first_pass (void)
+ {
+   _current_pass = all_passes;
+   return (const void *) _current_pass->name;
+ }
+ 
+ const struct feature feature_first_pass = {
+   "first_pass",                   /* name */
+   NULL,                           /* data */
+   0,				  /* no data */
+   &first_pass,                    /* callback */
+   NULL,				  /* no get subfeature callback */
+   NULL				  /* no set subfeature callback */
+ };
+ 
+ /* FICI0: "next_pass": get the name of the next pass to be executed */
+ static const void *next_pass (void)
+ {
+   if(_current_pass == NULL)
+     {
+       return (const void *) NULL;
+     }
+ 
+   if(_current_pass->sub != NULL)
+     {
+       /* Insert _current_pass->next in parents list */
+       _pass_parents[_pass_parents_count++] = _current_pass->next;
+       _current_pass = _current_pass->sub;
+ 
+       return (const void *) _current_pass->name;
+     }
+   
+   if(_current_pass->next == NULL)
+     {
+       while(_pass_parents[_pass_parents_count] == NULL
+ 	    && _pass_parents_count > 0)
+ 	_pass_parents_count--;
+ 
+       _current_pass = _pass_parents[_pass_parents_count];
+       /* Delete _current_pass in parents list */
+       _pass_parents[_pass_parents_count] = NULL;
+ 
+       return (const void *) (_current_pass != NULL ? 
+ 			     _current_pass->name :
+ 			     NULL);
+     }
+ 
+   _current_pass = _current_pass->next;
+   return (const void *) _current_pass->name;
+ }
+ 
+ const struct feature feature_next_pass = {
+   "next_pass",                    /* name */
+   NULL,                           /* data */
+   0,				  /* data size */
+   &next_pass,                     /* callback */
+   NULL,				  /* no get subfeature callback */
+   NULL				  /* no set subfeature callback */
+ };
+ 
+ 
+ /* FICI0: compiler_all_passes */
+ /* list of all passes requires names or address/sourceloc of each instance */
+ static const void *
+ all_gcc_pass_names (void); /* forward declaration - code references feature */
+ 
+ struct feature feature_named_passes = {
+   "named_passes",                 /* name */
+   NULL,                           /* initial data */
+   0,				  /* initially no data */
+   &all_gcc_pass_names,            /* callback */
+   NULL,				  /* no get subfeature callback */
+   NULL				  /* no set subfeature callback */  
+ };
+ 
+ 
+ static const void *
+ all_gcc_pass_names (void)
+ {
+   int i;
+   char *new_name;
+   const char **pass_name =
+     (const char **) xmalloc (passes_by_id_size * sizeof (const char *));
+ 
+   for (i = 0;  i < passes_by_id_size; i++)
+     {
+       if (passes_by_id[i] == NULL)
+ 	pass_name[i] = "<no pass defined>";
+       else
+ 	{
+ 	  if (passes_by_id[i]->name != NULL)
+ 	    pass_name[i] = passes_by_id[i]->name;
+ 	  else
+ 	    {
+ 	      /* be defensive - do not allow string overflow */
+ 	      gcc_assert (passes_by_id_size < 1000);
+ 	      new_name = (char *) xmalloc (strlen ("pass_XXX") + 1);
+ 	      sprintf (new_name, "pass_%03d", i);
+ 	      /* store the new name in the option as well */
+ 	      /* to keep memory clean when freeing a pass, any non-NULL
+ 		 pass name of the format "pass_%03d" should be freed as
+ 		 well, because it was dynamically allocated. */
+ 	      pass_name[i] = passes_by_id[i]->name = (const char *) new_name;
+ 	    }
+ 	}
+     }
+ 
+   /* memoize the result */
+   feature_named_passes.data = (void *) pass_name ;
+   feature_named_passes.data_size =
+     passes_by_id_size * sizeof (char *);
+   return (void *) pass_name;
+ }
+ 
+ 
+ /* FICI0: get name of the current pass */
+ static const void *
+ get_gcc_pass_name (void)
+ {
+   return (const void *) get_current_pass_name ();
+ }
+ 
+ 
+ const struct feature feature_crnt_pass_name = {
+   "pass_name",                    /* name */
+   NULL,                           /* data */
+   0,				  /* no data */
+   &get_gcc_pass_name,             /* callback */
+   NULL,				  /* no get subfeature callback */
+   NULL				  /* no set subfeature callback */
+ };
+ 
+ 
+ /* FICI0: "compiler_version": get version string of the compiler */
+ static const void *
+ get_compiler_version_string (void);
+ 
+ 
+ /* FICI0: query compiler version */
+ const struct feature feature_compiler_version = {
+   "compiler_version",		  /* GCC version */
+   NULL,				  /* data */
+   0,				  /* no data */
+   get_compiler_version_string,    /* data: version_string of GCC */
+   NULL,				  /* no get subfeature callback */
+   NULL				  /* no set subfeature callback */
+ };
+ 
+ 
+ static const void *
+ get_compiler_version_string (void)
+ {
+   /* this is the time to memoize the value if necessary */
+   return (const void *) version_string;
+ }
+ 
+ 
+ /* FICI0: "flags": get the command-line flags of the compiler
+  * return values:
+  *  - string subfeatures: pointer-to-char corresponding to the string;
+  *  - integer/boolean/bit subfeatures: integer converted to pointer-to-void.
+  */
+ static const void *get_gcc_option_names(void);
+ 
+ static const void *
+ get_gcc_option_value (const char *opt)
+ {
+   size_t opt_index;
+   const struct cl_option *option;
+   struct cl_option_state state;
+   bool was_set;
+   
+   opt_index = find_opt (opt, -1);
+   if (opt_index == cl_options_count)
+     return (const char *) NULL;
+   
+   /* at this point, the option is known to exist */
+   option = &cl_options[opt_index];
+   was_set = get_option_state (opt_index, &state);
+ 	   
+   /* check if option is set, and return the value (int or ptr); IMPORANT:
+      the user has to know how to interpret the value that's returned. */
+   if (!was_set)
+     return (const void *) NULL;
+   else switch (cl_options[opt_index].var_type) {
+     case CLVC_STRING:
+       /* for string options, return actual string */
+       return (state.data ? state.data : (const void *) "");
+ 
+     case CLVC_BOOLEAN:
+     case CLVC_EQUAL:
+       /* booleans and integers are stored by converting them to a 'const
+ 	 void *'. */
+       return state.data;
+     case CLVC_BIT_CLEAR:
+     case CLVC_BIT_SET:
+       /* bits set/cleared: return the char (0 or 1) converted to 'const void *' */
+       return (const void *) ((long int) state.ch);
+     default:
+       gcc_unreachable ();
+     }
+ }
+ 
+ 
+ /* value is a pointer to the actual value.  NULL means no value.
+    Implementation is based on static unsigned int handle_option in gcc/opts.c
+ */
+ static void *
+ set_gcc_option_value (const char *opt __attribute__ ((unused)),
+ 		      void *value __attribute__ ((unused)))
+ {
+   /* not implemented yet */
+   return NULL;
+ }
+ 
+ 
+ /* FICI0: "compiler_flags": get list/values of compiler flags.  Example:
+    call 'ici_get_feature ("compiler_params")' to get the list of parameters.
+    The value returned by this call will be memoized in the 'data' field.
+    Reset the 'data' field to NULL (and 'data_size' to zero) to force
+    a recomputation of the list.
+ */
+ struct feature feature_compiler_flags = {
+   "compiler_flags",		/* name */
+   NULL,				/* initially NULL to trigger callback, later
+ 				   stores the memoized result */
+   0,				/* no data */
+   get_gcc_option_names,		/* return list of option names */
+   get_gcc_option_value,		/* get value of named option */
+   set_gcc_option_value		/* set value of named option */
+ };
+ 
+ 
+ static const void *get_gcc_option_names (void)
+ {
+   size_t i;
+ 
+   const char **option_names =
+     (const char **) xmalloc (cl_options_count * sizeof (const char *));
+ 
+   for (i = 0; i < cl_options_count; i++)
+     option_names[i] = cl_options[i].opt_text;
+ 
+   feature_compiler_flags.data = option_names;
+   feature_compiler_flags.data_size = cl_options_count * sizeof (const char *);
+ 
+   return (const void *) option_names;
+ }
+ 
+ 
+ /* FICI0: "compiler_params": get list/values of compiler parameters. */
+ 
+ /* forward declaration - definition follows feature initializer */
+ static const void *get_gcc_param_names (void);
+ 
+ 
+ static const void *
+ get_gcc_param_value (const char *name)
+ {
+   size_t i;
+ 
+   /* Scan the parameter table to find a matching entry - from 'set_param_value'  */
+   for (i = 0; i < num_compiler_params; ++i)
+     if (strcmp (compiler_params[i].option, name) == 0)
+       return (void *) ((long int) compiler_params[i].value);
+ 
+   /* If we didn't find the parameter, return the invalid parameter value */
+   return (void *)(-1);
+ }
+ 
+ static void *set_gcc_param_value (const char *name, void *value)
+ {
+   size_t i;
+ 
+   /* Scan the parameter table to find a matching entry - from 'set_param_value'  */
+   for (i = 0; i < num_compiler_params; ++i)
+     if (strcmp (compiler_params[i].option, name) == 0)
+       compiler_params[i].value = (int) ((long int) value);
+ 
+   /* If we didn't find the parameter, return the invalid parameter value */
+   return (void *)(-1); 
+ }
+ 
+ /* FICI0: "compiler_params": get list/values of compiler parameters.
+    Call 'ici_get_feature ("compiler_params")' to get the list of parameters.
+    The value returned by this call will be memoized in the 'data' field.
+    Reset the 'data' field to NULL (and 'data_size' to zero) to force
+    a recomputation of the list.
+ */
+ struct feature feature_compiler_params = {
+   "compiler_params",		/* name */
+   NULL,				/* initially NULL to trigger callback, later
+ 				   stores memoized callback result */
+   0,				/* no data */
+   get_gcc_param_names,		/* return list of parameter names */
+   get_gcc_param_value,		/* get value of named parameter - always an integer */
+   set_gcc_param_value		/* set value of named parameter */
+ };
+ 
+ 
+ static const void *
+ get_gcc_param_names (void)
+ {
+   size_t i;
+   const char **param_list =
+     (const char **) xmalloc (num_compiler_params * sizeof (const char *));
+ 
+   /* collect all parameter names */
+   for (i = 0; i < num_compiler_params; i++)
+     param_list[i] = compiler_params[i].option;
+ 
+   /* memoize list in feature descriptor */
+   feature_compiler_params.data = param_list;
+   feature_compiler_params.data_size =
+     num_compiler_params * sizeof (const char *);
+   
+   return (void *) param_list;
+ }
+ 
+ 
+ /* FICI3: Get cfun source code information:
+    - declaration line
+    - declaration filename
+    - definition start/end line
+    - definition filename
+ */
+ 
+ static const void *
+ get_cfun_decl_line (void)
+ {
+   if (!cfun)
+     return (const void *) -1;
+ 
+   return (const void *) ((long int) LOCATION_LINE (DECL_SOURCE_LOCATION (cfun->decl)));
+ }
+ 
+ static const void *
+ get_cfun_decl_filename (void)
+ {
+   if (!cfun)
+     return NULL;
+ 
+   return (const void *) LOCATION_FILE (DECL_SOURCE_LOCATION (cfun->decl));
+ }
+ 
+ static const void *
+ get_cfun_def_start_line (void)
+ {
+   if (!cfun)
+     return (const void *) -1;
+ 
+   return (const void *) ((long int) LOCATION_LINE (cfun->function_start_locus));
+ }
+ 
+ static const void *
+ get_cfun_def_end_line (void)
+ {
+   if (!cfun)
+     return (const void *) -1;
+ 
+   return (const void *) ((long int) LOCATION_LINE (cfun->function_end_locus)); 
+ }
+ 
+ static const void *
+ get_cfun_def_filename (void)
+ {
+   if (!cfun)
+     return NULL;
+ 
+   return (const void *) LOCATION_FILE (cfun->function_start_locus);
+ }
+ 
+ const struct feature feature_function_start = {
+   "function_start_line",          /* name */
+   NULL,                           /* data */
+   0,				  /* no data */
+   &get_cfun_def_start_line,       /* callback */
+   NULL,				  /* no get subfeature callback */
+   NULL				  /* no set subfeature callback */
+ };
+ 
+ const struct feature feature_function_end = {
+   "function_end_line",            /* name */
+   NULL,                           /* data */
+   0,				  /* no data */
+   &get_cfun_def_end_line,         /* callback */
+   NULL,				  /* no get subfeature callback */
+   NULL				  /* no set subfeature callback */
+ };
+ 
+ const struct feature feature_function_file = {
+   "function_filename",            /* name */
+   NULL,                           /* data */
+   0,				  /* no data */
+   &get_cfun_def_filename,         /* callback */
+   NULL,				  /* no get subfeature callback */
+   NULL				  /* no set subfeature callback */
+ };
+ 
+ const struct feature feature_function_decl_line = {
+   "function_decl_line",           /* name */
+   NULL,                           /* data */
+   0,				  /* no data */
+   &get_cfun_decl_line,            /* callback */
+   NULL,				  /* no get subfeature callback */
+   NULL				  /* no set subfeature callback */
+ };
+ 
+ const struct feature feature_function_decl_file = {
+   "function_decl_filename",       /* name */
+   NULL,                           /* data */
+   0,				  /* no data */
+   &get_cfun_decl_filename,        /* callback */
+   NULL,				  /* no get subfeature callback */
+   NULL				  /* no set subfeature callback */
+ };
+ 
+ 
+ /* FICI0: initialize all known features */
+ void init_features (void)
+ {
+   register_feature (&feature_function_name); 
+   register_feature (&feature_crnt_pass_name);
+ 
+   register_feature (&feature_first_pass); 
+   register_feature (&feature_next_pass);
+   register_feature (&feature_compiler_version);
+ 
+   register_feature (&feature_compiler_flags);
+   register_feature (&feature_compiler_params);
+   register_feature (&feature_named_passes);
+ 
+   register_feature (&feature_function_start);
+   register_feature (&feature_function_end);
+   register_feature (&feature_function_file);
+   register_feature (&feature_function_decl_line);
+   register_feature (&feature_function_decl_file);
+ }
+ 
diff -crBN ../gcc-4.4.4/gcc/final.c gcc-4.4.4/gcc/final.c
*** ../gcc-4.4.4/gcc/final.c	2008-12-10 09:46:40.000000000 +0100
--- gcc-4.4.4/gcc/final.c	2010-05-05 23:12:10.000000000 +0200
***************
*** 4220,4226 ****
  {
   {
    RTL_PASS,
!   NULL,                                 /* name */
    NULL,                                 /* gate */
    rest_of_handle_final,                 /* execute */
    NULL,                                 /* sub */
--- 4220,4226 ----
  {
   {
    RTL_PASS,
!   "final",                              /* name */
    NULL,                                 /* gate */
    rest_of_handle_final,                 /* execute */
    NULL,                                 /* sub */
***************
*** 4332,4338 ****
  {
   {
    RTL_PASS,
!   NULL,                                 /* name */
    NULL,                                 /* gate */
    rest_of_clean_state,                  /* execute */
    NULL,                                 /* sub */
--- 4332,4338 ----
  {
   {
    RTL_PASS,
!   "clean_state",                        /* name */
    NULL,                                 /* gate */
    rest_of_clean_state,                  /* execute */
    NULL,                                 /* sub */
diff -crBN ../gcc-4.4.4/gcc/fortran/Make-lang.in gcc-4.4.4/gcc/fortran/Make-lang.in
*** ../gcc-4.4.4/gcc/fortran/Make-lang.in	2008-12-11 12:29:38.000000000 +0100
--- gcc-4.4.4/gcc/fortran/Make-lang.in	2010-05-05 23:12:10.000000000 +0200
***************
*** 97,103 ****
  # The compiler itself is called f951.
  f951$(exeext): $(F95_OBJS) \
  		$(BACKEND) $(LIBDEPS) attribs.o
! 	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ \
  		$(F95_OBJS) $(BACKEND) $(LIBS) attribs.o $(BACKENDLIBS)
  
  gt-fortran-trans.h    : s-gtype; @true
--- 97,103 ----
  # The compiler itself is called f951.
  f951$(exeext): $(F95_OBJS) \
  		$(BACKEND) $(LIBDEPS) attribs.o
! 	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -export-dynamic -o $@ \
  		$(F95_OBJS) $(BACKEND) $(LIBS) attribs.o $(BACKENDLIBS)
  
  gt-fortran-trans.h    : s-gtype; @true
diff -crBN ../gcc-4.4.4/gcc/function.c gcc-4.4.4/gcc/function.c
*** ../gcc-4.4.4/gcc/function.c	2009-11-13 20:57:51.000000000 +0100
--- gcc-4.4.4/gcc/function.c	2010-05-05 23:12:10.000000000 +0200
***************
*** 4233,4239 ****
  {
   {
    RTL_PASS,
!   NULL,                                 /* name */
    NULL,                                 /* gate */   
    init_function_for_compilation,        /* execute */       
    NULL,                                 /* sub */
--- 4233,4239 ----
  {
   {
    RTL_PASS,
!   "init_function",                      /* name */
    NULL,                                 /* gate */   
    init_function_for_compilation,        /* execute */       
    NULL,                                 /* sub */
***************
*** 5474,5480 ****
  {
   {
    RTL_PASS,
!   NULL,                                 /* name */
    NULL,                                 /* gate */
    rest_of_handle_check_leaf_regs,       /* execute */
    NULL,                                 /* sub */
--- 5474,5480 ----
  {
   {
    RTL_PASS,
!   "leaf_regs",                          /* name */
    NULL,                                 /* gate */
    rest_of_handle_check_leaf_regs,       /* execute */
    NULL,                                 /* sub */
diff -crBN ../gcc-4.4.4/gcc/highlev-plugin.h gcc-4.4.4/gcc/highlev-plugin.h
*** ../gcc-4.4.4/gcc/highlev-plugin.h	1970-01-01 01:00:00.000000000 +0100
--- gcc-4.4.4/gcc/highlev-plugin.h	2010-05-05 23:12:10.000000000 +0200
***************
*** 0 ****
--- 1,51 ----
+ /* Plugin-side interface for high-level plugins in GCC.
+    Copyright (C) 2009 Free Software Foundation, Inc.
+    
+    Contributed by Inria.
+ 
+    Authors: Grigori Fursin <gfursin@gmail.com>, Cupertino Miranda
+    <cupertinomiranda@gmail.com>, Zbigniew Chamski <zbigniew.chamski@gmail.com>.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify it under
+ the terms of the GNU General Public License as published by the Free
+ Software Foundation; either version 3, or (at your option) any later
+ version.
+ 
+ GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+ WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING3.  If not see
+ <http://www.gnu.org/licenses/>.  */
+ 
+ #ifndef HIGHLEV_PLUGIN_H
+ #define HIGHLEV_PLUGIN_H
+ 
+ /* Callback type for high-level argument-less event callbacks */
+ typedef void (*event_callback_t) (void);
+ 
+ /* manipulation of event tables and callback lists */
+ extern void register_plugin_event (const char *name, event_callback_t func);
+ extern void unregister_plugin_event (const char *name);
+ extern int call_plugin_event (const char *event_name);
+ extern const char **list_plugin_events (void);
+ 
+ /* return codes for call_plugin_event */
+ #define PLUGEVT_SUCCESS         0
+ #define PLUGEVT_NO_EVENTS       1
+ #define PLUGEVT_NO_SUCH_EVENT   2
+ #define PLUGEVT_NO_CALLBACK     3
+ 
+ /* manipulation of event parameter (callback arg) tables */
+ extern const char **list_event_parameters (void);
+ extern void *get_event_parameter (const char *name);
+ 
+ /* pass management */
+ extern void run_pass (char *pass_name);
+ extern const char **list_passes (void);
+ 
+ #endif /* HIGHLEV_PLUGIN_H */
diff -crBN ../gcc-4.4.4/gcc/highlev-plugin-internal.h gcc-4.4.4/gcc/highlev-plugin-internal.h
*** ../gcc-4.4.4/gcc/highlev-plugin-internal.h	1970-01-01 01:00:00.000000000 +0100
--- gcc-4.4.4/gcc/highlev-plugin-internal.h	2010-05-05 23:12:10.000000000 +0200
***************
*** 0 ****
--- 1,53 ----
+ /* Compiler-side interface for high-level plugins in GCC.
+    Copyright (C) 2009 Free Software Foundation, Inc.
+    
+    Contributed by Inria.
+ 
+    Authors: Grigori Fursin <gfursin@gmail.com>, Cupertino Miranda
+    <cupertinomiranda@gmail.com>, Zbigniew Chamski <zbigniew.chamski@gmail.com>.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify it under
+ the terms of the GNU General Public License as published by the Free
+ Software Foundation; either version 3, or (at your option) any later
+ version.
+ 
+ GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+ WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING3.  If not see
+ <http://www.gnu.org/licenses/>.  */
+ 
+ #ifndef HIGHLEV_PLUGIN_INTERNAL
+ #define HIGHLEV_PLUGIN_INTERNAL
+ 
+ /* Callback type for high-level argument-less event callbacks */
+ typedef void (*event_callback_t) (void);
+ 
+ /* Manipulation of events and event handlers */
+ extern void register_plugin_event (const char *name, event_callback_t func);
+ extern void unregister_plugin_event (const char *name);
+ extern const char **list_plugin_events (void);
+ extern int call_plugin_event (const char *event_name);
+ 
+ /* return codes for call_plugin_event */
+ #define PLUGEVT_SUCCESS         0
+ #define PLUGEVT_NO_EVENTS       1
+ #define PLUGEVT_NO_SUCH_EVENT   2
+ #define PLUGEVT_NO_CALLBACK     3
+ 
+ /* Manipulation of event parameters (callback arguments) */
+ extern void register_event_parameter (const char *name, void *param);
+ extern void unregister_event_parameter (const char *name);
+ extern const char **list_event_parameters (void);
+ extern void *get_event_parameter (const char *name);
+ 
+ /* ICI-specific, environment-based plugin loading */
+ extern void load_ici_plugin (void);
+ extern void unload_ici_plugin (void);
+ 
+ #endif /* HIGHLEV_PLUGIN_INTERNAL_H*/
diff -crBN ../gcc-4.4.4/gcc/ici-legacy.h gcc-4.4.4/gcc/ici-legacy.h
*** ../gcc-4.4.4/gcc/ici-legacy.h	1970-01-01 01:00:00.000000000 +0100
--- gcc-4.4.4/gcc/ici-legacy.h	2010-05-05 23:12:10.000000000 +0200
***************
*** 0 ****
--- 1,24 ----
+ #define event_func		event_callback_t
+ #define ici_register_event	register_plugin_event
+ #define ici_get_parameter	get_event_parameter
+ #define ici_list_events		list_plugin_events
+ #define ici_list_parameters	list_event_parameters
+ 
+ #define ici_run_pass		run_pass
+ #define ici_add_pass		register_pass
+ #define ici_list_passes		list_passes
+ #define ici_load		load_ici_plugin
+ #define ici_unload		unload_ici_plugin
+ 
+ #define ici_init_features	init_features
+ #define ici_find_feature	find_feature
+ #define ici_get_feature		get_feature
+ #define ici_get_subfeature	get_subfeature
+ #define ici_set_subfeature	set_subfeature
+ #define ici_get_feature_size	get_feature_size
+ #define ici_get_available_features list_features
+ #define ici_get_num_available_features get_num_features
+ #define ici_get_available_subfeatures list_subfeatures
+ #define ici_get_num_available_subfeatures get_sub_subfeatures
+ #define ici_init_features	init_features
+ #define ici_list_features	list_features
diff -crBN ../gcc-4.4.4/gcc/ic-interface.h gcc-4.4.4/gcc/ic-interface.h
*** ../gcc-4.4.4/gcc/ic-interface.h	1970-01-01 01:00:00.000000000 +0100
--- gcc-4.4.4/gcc/ic-interface.h	2010-05-05 23:12:10.000000000 +0200
***************
*** 0 ****
--- 1,33 ----
+ /* Toplevel interface file for legacy ICI plugins.
+    Copyright (C) 2009 Free Software Foundation, Inc.
+    
+    Contributed by Inria.
+ 
+    Authors: Grigori Fursin <gfursin@gmail.com>, Cupertino Miranda
+    <cupertinomiranda@gmail.com>, Zbigniew Chamski <zbigniew.chamski@gmail.com>.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify it under
+ the terms of the GNU General Public License as published by the Free
+ Software Foundation; either version 3, or (at your option) any later
+ version.
+ 
+ GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+ WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING3.  If not see
+ <http://www.gnu.org/licenses/>.  */
+ 
+ #ifndef IC_INTERFACE_H
+ #define IC_INTERFACE_H
+ 
+ #include <stdio.h>
+ #include "highlev-plugin.h"
+ #include "feature.h"
+ #include "pass-manager.h"
+ 
+ #endif /* IC_INTERFACE_H */
diff -crBN ../gcc-4.4.4/gcc/ipa-inline.c gcc-4.4.4/gcc/ipa-inline.c
*** ../gcc-4.4.4/gcc/ipa-inline.c	2010-02-08 15:10:15.000000000 +0100
--- gcc-4.4.4/gcc/ipa-inline.c	2010-05-05 23:12:10.000000000 +0200
***************
*** 1640,1646 ****
  {
   {
    GIMPLE_PASS,
!   NULL,	 				/* name */
    NULL,					/* gate */
    compute_inline_parameters_for_current,/* execute */
    NULL,					/* sub */
--- 1640,1646 ----
  {
   {
    GIMPLE_PASS,
!   "inline_parameters",			/* name */
    NULL,					/* gate */
    compute_inline_parameters_for_current,/* execute */
    NULL,					/* sub */
diff -crBN ../gcc-4.4.4/gcc/loop-unroll.c gcc-4.4.4/gcc/loop-unroll.c
*** ../gcc-4.4.4/gcc/loop-unroll.c	2009-02-20 16:20:38.000000000 +0100
--- gcc-4.4.4/gcc/loop-unroll.c	2010-05-05 23:12:10.000000000 +0200
***************
*** 33,38 ****
--- 33,39 ----
  #include "expr.h"
  #include "hashtab.h"
  #include "recog.h"    
+ #include "highlev-plugin-internal.h"
  
  /* This pass performs loop unrolling and peeling.  We only perform these
     optimizations on innermost loops (with single exception) because
***************
*** 163,168 ****
--- 164,192 ----
    FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)
      {
        check = true;
+       {
+         /* Code for loop-unrolling ICI decision enabling.  */
+         register_event_parameter ("loop->num", &(loop->num));
+         register_event_parameter ("loop->ninsns", &(loop->ninsns));
+         register_event_parameter ("loop->av_ninsns", &(loop->av_ninsns));
+         
+         register_event_parameter ("loop->lpt_decision.times", &(loop->lpt_decision.times));
+         register_event_parameter ("loop->lpt_decision.decision", &(loop->lpt_decision.decision));
+         register_event_parameter ("loop->lpt_decision.unroll_runtime", 
+               loop->lpt_decision.decision == LPT_UNROLL_RUNTIME ? (void *) 1 : (void *) 0);
+         register_event_parameter ("loop->lpt_decision.unroll_constant", 
+               loop->lpt_decision.decision == LPT_UNROLL_CONSTANT ? (void *) 1 : (void *) 0);
+ 
+         call_plugin_event("unroll_feature_change");
+ 
+         unregister_event_parameter ("loop->num");
+         unregister_event_parameter ("loop->ninsns");
+ 
+         unregister_event_parameter ("loop->av_ninsns");
+         unregister_event_parameter ("loop->lpt_decision.times");
+         unregister_event_parameter ("loop->lpt_decision.decision");
+       }
+ 
        /* And perform the appropriate transformations.  */
        switch (loop->lpt_decision.decision)
  	{
diff -crBN ../gcc-4.4.4/gcc/Makefile.in gcc-4.4.4/gcc/Makefile.in
*** ../gcc-4.4.4/gcc/Makefile.in	2010-03-08 12:46:28.000000000 +0100
--- gcc-4.4.4/gcc/Makefile.in	2010-05-05 23:12:10.000000000 +0200
***************
*** 297,302 ****
--- 297,305 ----
  DECNUMINC = -I$(DECNUM) -I$(DECNUMFMT) -I../libdecnumber
  LIBDECNUMBER = ../libdecnumber/libdecnumber.a
  
+ # Where to find DynLibrary loader and how to export internal symbols to DLs
+ LIBDL = -ldl -rdynamic
+ 
  # Substitution type for target's getgroups 2nd arg.
  TARGET_GETGROUPS_T = @TARGET_GETGROUPS_T@
  
***************
*** 914,920 ****
  # How to link with both our special library facilities
  # and the system's installed libraries.
  LIBS = @LIBS@ $(CPPLIB) $(LIBINTL) $(LIBICONV) $(LIBIBERTY) $(LIBDECNUMBER)
! BACKENDLIBS = $(CLOOGLIBS) $(PPLLIBS) $(GMPLIBS)
  # Any system libraries needed just for GNAT.
  SYSLIBS = @GNAT_LIBEXC@
  
--- 917,923 ----
  # How to link with both our special library facilities
  # and the system's installed libraries.
  LIBS = @LIBS@ $(CPPLIB) $(LIBINTL) $(LIBICONV) $(LIBIBERTY) $(LIBDECNUMBER)
! BACKENDLIBS = $(CLOOGLIBS) $(PPLLIBS) $(GMPLIBS) $(LIBDL)
  # Any system libraries needed just for GNAT.
  SYSLIBS = @GNAT_LIBEXC@
  
***************
*** 1097,1106 ****
--- 1100,1112 ----
  	ebitmap.o \
  	emit-rtl.o \
  	et-forest.o \
+ 	events.o \
  	except.o \
  	explow.o \
  	expmed.o \
  	expr.o \
+ 	feature.o \
+ 	feature-list.o \
  	final.o \
  	fixed-value.o \
  	fold-const.o \
***************
*** 1145,1150 ****
--- 1151,1157 ----
  	loop-unroll.o \
  	loop-unswitch.o \
  	lower-subreg.o \
+ 	ml-feat.o \
  	mcf.o \
  	mode-switching.o \
  	modulo-sched.o \
***************
*** 1155,1161 ****
--- 1162,1170 ----
  	opts-common.o \
  	opts.o \
  	params.o \
+ 	pass-manager.o \
  	passes.o \
+ 	plugin-loader.o \
  	pointer-set.o \
  	postreload-gcse.o \
  	postreload.o \
***************
*** 2445,2455 ****
     value-prof.h $(PARAMS_H) $(TM_P_H) reload.h ira.h dwarf2asm.h $(TARGET_H) \
     langhooks.h insn-flags.h $(CFGLAYOUT_H) $(CFGLOOP_H) hosthooks.h \
     $(CGRAPH_H) $(COVERAGE_H) alloc-pool.h $(GGC_H) $(INTEGRATE_H) \
!    opts.h params.def tree-mudflap.h $(REAL_H) tree-pass.h $(GIMPLE_H)
  	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) \
  	  -DTARGET_NAME=\"$(target_noncanonical)\" \
  	  -c $(srcdir)/toplev.c $(OUTPUT_OPTION)
  
  passes.o : passes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
     $(RTL_H) $(FUNCTION_H) $(FLAGS_H) xcoffout.h $(INPUT_H) $(INSN_ATTR_H) output.h \
     $(DIAGNOSTIC_H) debug.h insn-config.h intl.h $(RECOG_H) $(TOPLEV_H) \
--- 2454,2482 ----
     value-prof.h $(PARAMS_H) $(TM_P_H) reload.h ira.h dwarf2asm.h $(TARGET_H) \
     langhooks.h insn-flags.h $(CFGLAYOUT_H) $(CFGLOOP_H) hosthooks.h \
     $(CGRAPH_H) $(COVERAGE_H) alloc-pool.h $(GGC_H) $(INTEGRATE_H) \
!    opts.h params.def tree-mudflap.h $(REAL_H) tree-pass.h $(GIMPLE_H) \
! 	highlev-plugin-internal.h
  	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) \
  	  -DTARGET_NAME=\"$(target_noncanonical)\" \
  	  -c $(srcdir)/toplev.c $(OUTPUT_OPTION)
  
+ pass-manager.o : pass-manager.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TOPLEV_H) \
+    $(HASHTAB_H) tree-pass.h highlev-plugin-internal.h feature-internal.h \
+    pass-manager.h
+ 
+ events.o : events.c  $(CONFIG_H) $(SYSTEM_H) coretypes.h $(HASHTAB_H) \
+    $(TOPLEV_H) errors.h highlev-plugin-internal.h
+ 
+ feature.o : feature.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(HASHTAB_H) \
+    $(TOPLEV_H) feature-internal.h
+ 
+ feature-list.o : feature-list.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+    $(TREE_H) $(INPUT_H) $(BASIC_BLOCK_H) $(TREE_INLINE_H) $(TREE_FLOW_H) \
+    tree-pass.h version.h opts.h params.h function.h feature-internal.h
+ 
+ plugin-loader.o : plugin-loader.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(HASHTAB_H) \
+    $(TOPLEV_H) $(GCC_H) options.h highlev-plugin-internal.h feature-internal.h
+ 
  passes.o : passes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
     $(RTL_H) $(FUNCTION_H) $(FLAGS_H) xcoffout.h $(INPUT_H) $(INSN_ATTR_H) output.h \
     $(DIAGNOSTIC_H) debug.h insn-config.h intl.h $(RECOG_H) $(TOPLEV_H) \
***************
*** 2459,2465 ****
     langhooks.h insn-flags.h $(CFGLAYOUT_H) $(REAL_H) $(CFGLOOP_H) \
     hosthooks.h $(CGRAPH_H) $(COVERAGE_H) tree-pass.h $(TREE_DUMP_H) \
     $(GGC_H) $(INTEGRATE_H) $(CPPLIB_H) opts.h $(TREE_FLOW_H) $(TREE_INLINE_H) \
!    gt-passes.h $(DF_H) $(PREDICT_H)
  
  main.o : main.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TOPLEV_H)
  
--- 2486,2492 ----
     langhooks.h insn-flags.h $(CFGLAYOUT_H) $(REAL_H) $(CFGLOOP_H) \
     hosthooks.h $(CGRAPH_H) $(COVERAGE_H) tree-pass.h $(TREE_DUMP_H) \
     $(GGC_H) $(INTEGRATE_H) $(CPPLIB_H) opts.h $(TREE_FLOW_H) $(TREE_INLINE_H) \
!    gt-passes.h $(DF_H) $(PREDICT_H) highlev-plugin-internal.h pass-manager.h
  
  main.o : main.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TOPLEV_H)
  
***************
*** 2829,2834 ****
--- 2856,2865 ----
     $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) $(PARAMS_H) \
     output.h $(EXPR_H) coretypes.h $(TM_H) $(HASHTAB_H) $(RECOG_H) \
     $(OBSTACK_H)
+ ml-feat.o: ml-feat.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \
+    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) $(PARAMS_H) \
+    output.h $(EXPR_H) coretypes.h $(TM_H) $(HASHTAB_H) $(RECOG_H) \
+    $(OBSTACK_H)
  dominance.o : dominance.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
     hard-reg-set.h $(BASIC_BLOCK_H) et-forest.h $(OBSTACK_H) $(TOPLEV_H) \
     $(TIMEVAR_H) graphds.h vecprim.h pointer-set.h
diff -crBN ../gcc-4.4.4/gcc/ml-feat.c gcc-4.4.4/gcc/ml-feat.c
*** ../gcc-4.4.4/gcc/ml-feat.c	1970-01-01 01:00:00.000000000 +0100
--- gcc-4.4.4/gcc/ml-feat.c	2010-05-05 23:12:10.000000000 +0200
***************
*** 0 ****
--- 1,865 ----
+ #include "config.h"
+ #undef FLOAT /* This is for hpux. They should change hpux.  */
+ #undef FFS  /* Some systems define this in param.h.  */
+ #include "system.h"
+ #include "coretypes.h"
+ #include "tm.h"
+ #include <signal.h>
+ 
+ #ifdef HAVE_SYS_RESOURCE_H
+ # include <sys/resource.h>
+ #endif
+ 
+ #ifdef HAVE_SYS_TIMES_H
+ # include <sys/times.h>
+ #endif
+ 
+ #include "line-map.h"
+ #include "input.h"
+ #include "tree.h"
+ #include "rtl.h"
+ #include "tm_p.h"
+ #include "flags.h"
+ /* #include "insn-attr.h" */
+ #include "insn-config.h"
+ #include "insn-flags.h"
+ #include "hard-reg-set.h"
+ #include "recog.h"
+ #include "output.h"
+ #include "except.h"
+ #include "function.h"
+ #include "toplev.h"
+ #include "expr.h"
+ #include "basic-block.h"
+ #include "intl.h"
+ #include "ggc.h"
+ #include "graph.h"
+ #include "regs.h"
+ #include "timevar.h"
+ #include "diagnostic.h"
+ #include "params.h"
+ #include "reload.h"
+ #include "dwarf2asm.h"
+ #include "integrate.h"
+ #include "real.h"
+ #include "debug.h"
+ #include "target.h"
+ #include "langhooks.h"
+ #include "cfglayout.h"
+ #include "cfgloop.h"
+ #include "hosthooks.h"
+ #include "cgraph.h"
+ #include "opts.h"
+ /* #include "coverage.h" */
+ #include "value-prof.h"
+ #include "tree-inline.h"
+ #include "tree-flow.h"
+ #include "tree-pass.h"
+ #include "tree-dump.h"
+ #include "hashtab.h"
+ 
+ static FILE *ml_fp_interf = NULL;
+ 
+ /* #define MN_PRINT 1 */
+ 
+ static void
+ ml_feat_init (void)
+ {
+ #if 0
+   char ml_dump_base_name [MAXPATHLEN];
+   char ml_info_str1 [MAXPATHLEN];
+ 
+   strcpy (ml_info_str1, "/home/test/"); 
+   if (ml_info_str1[strlen(ml_info_str1)-1] != '/')
+     strcat (ml_info_str1, "/");
+   strcpy (ml_dump_base_name, dump_base_name);
+   ml_dump_base_name[strlen(ml_dump_base_name)-2]= '\0';
+   strcat (ml_info_str1, ml_dump_base_name);
+   strcat (ml_info_str1, "_");
+   /*      sprintf (ml_info_str, "%c", '~'); */
+   strcat (ml_info_str1, 
+ 	  lang_hooks.decl_printable_name (current_function_decl, 2));
+   strcat (ml_info_str1, ".");
+   strcat (ml_info_str1, "P");
+ 
+ #ifdef MN_PRINT
+   fprintf (stderr, "File inf is %s\n", ml_info_str1);
+ #endif
+ 
+   ml_fp_interf = fopen (ml_info_str1, "w");
+ #else
+   ml_fp_interf = fopen ("features.P", "w");
+ 
+ /* 
+   2010.02.24:
+   Grigori changed that to have mangled names when using C++ (Joern's suggestion)
+   fprintf (ml_fp_interf, "fn_name(fn,fn_%s).\n", lang_hooks.decl_printable_name (current_function_decl, 2));*/
+ 
+ /* 
+   2010.02.27:
+   Grigori put constant function name since some functions with . (such as 'T.53') 
+   crash prolog
+   fprintf (ml_fp_interf, "fn_name(fn,fn_%s).\n", current_function_assembler_name ()); */
+ 
+   fprintf (ml_fp_interf, "fn_name(fn,fn_%s).\n", "current_function");
+ #endif
+ }
+ 
+ static void
+ ml_feat_close (void)
+ {
+   fclose (ml_fp_interf);
+ }
+ 
+ static unsigned int expr_nr;
+ static unsigned int type_nr;
+ static unsigned int var_nr;
+ static unsigned int edge_nr;
+ static unsigned int stmt_nr;
+ 
+ /* The hash table for types.  */
+ struct ml_state 
+ {
+   htab_t var_decl_hash_table;
+   VEC(tree,heap) *var_decls;
+ 
+   htab_t type_decl_hash_table;
+   VEC(tree,heap) *type_decls;
+ };
+ 
+ struct ml_state *mls;
+ 
+ struct ml_decl 
+ {
+   tree t;
+   int index;
+ };
+ 
+ static hashval_t
+ key_ml_decl_node (const void *p)
+ {
+   const struct ml_decl *ds = (const struct ml_decl *) p;
+   return (hashval_t) DECL_UID (ds->t);
+ }
+ 
+ static int
+ eq_ml_decl_node (const void *p1, const void *p2)
+ {
+   const struct ml_decl *ds1 =
+     (const struct ml_decl *) p1;
+   const struct ml_decl *ds2 =
+     (const struct ml_decl *) p2;
+ 
+   return DECL_UID (ds1->t) == DECL_UID (ds2->t);
+ }
+ 
+ static hashval_t
+ key_ml_type_node (const void *p)
+ {
+   const struct ml_decl *ds = (const struct ml_decl *) p;
+   return (hashval_t) TYPE_UID (ds->t);
+ }
+ 
+ static int
+ eq_ml_type_node (const void *p1, const void *p2)
+ {
+   const struct ml_decl *ds1 =
+     (const struct ml_decl *) p1;
+   const struct ml_decl *ds2 =
+     (const struct ml_decl *) p2;
+ 
+   return TYPE_UID (ds1->t) == TYPE_UID (ds2->t);
+ }
+ 
+ static bool
+ ml_decl_index (htab_t table,
+ 	       unsigned int *next_index, tree name, 
+ 	       unsigned int *this_index)
+ {
+   void **slot;
+   struct ml_decl d_slot;
+   d_slot.t = name;
+ 
+   slot = htab_find_slot (table, &d_slot, INSERT);
+   if (*slot == NULL)
+     {
+       struct ml_decl *new_slot = xmalloc (sizeof (struct ml_decl));
+       int index = (*next_index);
+ 
+       new_slot->t = name;
+       new_slot->index = index;
+       *this_index = index;
+       *slot = new_slot;
+       return true;
+     }
+   else
+     {
+       struct ml_decl *old_slot = (struct ml_decl *)*slot;
+       *this_index = old_slot->index;
+       return false;
+     }
+ }
+ 
+ static int
+ ml_decl_ref (tree node, unsigned int *index)
+ {
+   bool new;
+ 
+   new = ml_decl_index (mls->var_decl_hash_table,
+ 		       &var_nr, node, index);
+ 
+   if (new)
+     {
+       fprintf(ml_fp_interf,"var_p(v%d).\n",var_nr++);
+       VEC_safe_push (tree, heap, mls->var_decls, node);
+     }
+ 
+   return new;
+ }
+ 
+ static int
+ ml_type_ref (tree node, unsigned int *index)
+ {
+   bool new;
+ 
+   new = ml_decl_index (mls->type_decl_hash_table,
+ 		       &expr_nr, node, index);
+ 
+   if (new)
+     {
+       fprintf(ml_fp_interf,"type_p(e%d).\n",expr_nr++);
+       VEC_safe_push (tree, heap, mls->type_decls, node);
+     }
+ 
+   return new;
+ }
+ 
+ static void
+ ml_inp_expr (tree t, int expr_index)
+ {
+   tree x;
+   int i;
+   int prev_op;
+ 
+   if (t == NULL)
+     return;
+ 
+   fprintf (ml_fp_interf,"expr_class(e%d,%s).\n",
+ 	   expr_index,
+ 	   TREE_CODE_CLASS_STRING (TREE_CODE_CLASS(TREE_CODE (t))));
+ 
+   fprintf (ml_fp_interf,"expr_code(e%d,%s).\n",
+ 	   expr_index,
+ 	   tree_code_name [(int)TREE_CODE (t)]);
+ 
+   /* Flags */
+   if (t->common.base.addressable_flag)
+     fprintf (ml_fp_interf, "expr_flags(e%d,adddresable).\n",
+ 	     expr_index);
+ 
+   if (t->common.base.static_flag)
+     fprintf (ml_fp_interf, "expr_flags(e%d,static).\n",
+ 	     expr_index);
+ 
+ #if 0
+   /* removed in gcc44, may be saturating_flag instead?
+ http://gcc.gnu.org/ml/gcc-patches/2008-04/msg00431.html */
+   if (t->common.invariant_flag)
+     fprintf (ml_fp_interf, "expr_flags(e%d,invariant).\n",
+ 	     expr_index);
+ #endif
+ 
+   if (t->common.base.volatile_flag)
+     fprintf (ml_fp_interf, "expr_flags(e%d,volatile).\n",
+ 	     expr_index);
+ 
+   if (t->common.base.side_effects_flag)
+     fprintf (ml_fp_interf, "expr_flags(e%d,side_effects).\n",
+ 	     expr_index);
+ 
+   if (t->common.base.constant_flag)
+     fprintf (ml_fp_interf, "expr_flags(e%d,constant).\n",
+ 	     expr_index);
+ 
+   if (t->common.base.nothrow_flag)
+     fprintf (ml_fp_interf, "expr_flags(e%d,nothrow).\n",
+ 	     expr_index);
+ 
+   if (t->common.base.public_flag)
+     fprintf (ml_fp_interf, "expr_flags(e%d,public).\n",
+ 	     expr_index);
+ 
+   if (TREE_TYPE (t))
+     {
+       unsigned int index;
+       bool new;
+ 
+       new = ml_type_ref (TREE_TYPE (t), &index);
+ 
+       fprintf (ml_fp_interf,"expr_type(e%d,e%d). \n",
+ 		 expr_index,
+ 		 index);
+ 
+       if (new)
+ 	ml_inp_expr (TREE_TYPE (t), index);
+ #ifdef MN_PRINT
+       else
+ 	fprintf (ml_fp_interf,"type %d found \n", index);
+ #endif
+     }
+ 
+   fprintf (ml_fp_interf,"expr_code_len(e%d,%d).\n",
+ 	   expr_index,
+ 	   TREE_CODE_LENGTH (TREE_CODE (t)));
+ 
+   prev_op = -1;
+   for (i = 0; i < TREE_CODE_LENGTH (TREE_CODE (t)); i++)
+     {
+       if (!TREE_OPERAND (t, i))
+ 	continue;
+ 
+       if (prev_op == -1)
+ 	fprintf (ml_fp_interf, "expr_op_f(e%d,e%d).\n",
+ 		 expr_index, expr_nr);
+       else
+ 	fprintf (ml_fp_interf, "expr_op_n(e%d,e%d,e%d).\n",
+ 		 expr_index, prev_op, expr_nr);
+ 
+       prev_op = expr_nr;
+ 
+       ml_inp_expr (TREE_OPERAND (t, i), expr_nr++);
+     }
+ 
+   switch (TREE_CODE (t))
+     {
+     case SSA_NAME:
+       fprintf (ml_fp_interf, "expr_ssa_name(e%d,s%d).\n",
+ 	       expr_index, SSA_NAME_VERSION (t));
+ 
+       fprintf (ml_fp_interf, "expr_ssa_var(e%d,e%d).\n",
+ 	       expr_index, expr_nr);
+ 
+ #if 0 /* broken code */
+       fprintf (ml_fp_interf, "expr_ssa_def(e%d,%s).\n",
+ 	       expr_index,
+ 	       tree_code_name [(int)TREE_CODE (SSA_NAME_DEF_STMT(t))]);
+ #endif
+ 
+       ml_inp_expr (SSA_NAME_VAR (t), expr_nr++);
+       break;
+ 
+     case INTEGER_TYPE:
+       fprintf (ml_fp_interf, "expr_int_size(e%d,%d).\n",
+ 	       expr_index, TYPE_PRECISION(t));
+       break;
+ 
+     case INTEGER_CST:
+       if (TREE_INT_CST_HIGH (t) != 0)
+ 	break;
+ 
+       if ((long int)TREE_INT_CST_LOW (t) < 0)
+ 	break;
+ 
+       fprintf (ml_fp_interf, "expr_intcst_val(e%d,%d).\n",
+ 	       expr_index, (int)TREE_INT_CST_LOW (t));
+       break;
+ 
+     case ASSERT_EXPR:
+       break;
+ 
+     case LABEL_EXPR:
+       break;
+ 
+     case RESULT_DECL:
+     case FIELD_DECL:
+     case TYPE_DECL:
+     case FUNCTION_DECL:
+     case PARM_DECL:
+     case VAR_DECL:
+       {
+ 	unsigned int index;
+ 	bool new;
+ 
+ 	new = ml_decl_ref (t, &index);
+ 
+ 	fprintf (ml_fp_interf,"expr_var(e%d,v%d). \n",
+      	         expr_index,
+ 	         index);
+ 
+ #ifdef MN_PRINT
+ 	if (!new)
+ 	  fprintf (ml_fp_interf,"var %d found \n", index)
+ #endif
+       }
+       break;
+ 
+ 
+     case MODIFY_EXPR:
+       break;
+ 
+     case ADDR_EXPR:
+       {
+ 	/* Skip any references and ensure that any 
+            variable used as a prefix is marked
+ 	   addressable.  */
+ 	for (x = TREE_OPERAND (t, 0);
+ 	     handled_component_p (x);
+ 	     x = TREE_OPERAND (x, 0))
+ 	  ;
+ 
+ 	if (TREE_CODE (x) != VAR_DECL && TREE_CODE (x) != PARM_DECL)
+ 	  {
+ 	    return;
+ 	  }
+ 	if (!TREE_ADDRESSABLE (x))
+ 	  {
+ 	    error ("address taken, but ADDRESSABLE bit not set");
+ 	    return;
+ 	  }
+ 	break;
+       }
+ 
+     case COND_EXPR:
+       x = COND_EXPR_COND (t);
+       if (TREE_CODE (TREE_TYPE (x)) != BOOLEAN_TYPE)
+ 	{
+ 	  error ("non-boolean used in condition");
+ 	  return;
+ 	}
+       if (!is_gimple_condexpr (x))
+         {
+ 	  error ("invalid conditional operand");
+ 	  return;
+ 	}
+       break;
+ 
+     case NOP_EXPR:
+     case CONVERT_EXPR:
+     case FIX_TRUNC_EXPR:
+ #if 0 /* not present in gcc44 */ 
+     case FIX_CEIL_EXPR:
+     case FIX_FLOOR_EXPR:
+     case FIX_ROUND_EXPR:
+ #endif
+     case FLOAT_EXPR:
+     case NEGATE_EXPR:
+     case ABS_EXPR:
+     case BIT_NOT_EXPR:
+     case NON_LVALUE_EXPR:
+     case TRUTH_NOT_EXPR:
+       break;
+ 
+     case REALPART_EXPR:
+     case IMAGPART_EXPR:
+     case COMPONENT_REF:
+     case ARRAY_REF:
+     case ARRAY_RANGE_REF:
+     case BIT_FIELD_REF:
+     case VIEW_CONVERT_EXPR:
+       /* We have a nest of references.  Verify that each of the operands
+ 	 that determine where to reference is either a constant or a variable,
+ 	 verify that the base is valid */
+       while (handled_component_p (t))
+ 	{
+ 	  t = TREE_OPERAND (t, 0);
+ 	}
+ 
+       break;
+ 
+     case LT_EXPR:
+     case LE_EXPR:
+     case GT_EXPR:
+     case GE_EXPR:
+     case EQ_EXPR:
+     case NE_EXPR:
+     case UNORDERED_EXPR:
+     case ORDERED_EXPR:
+     case UNLT_EXPR:
+     case UNLE_EXPR:
+     case UNGT_EXPR:
+     case UNGE_EXPR:
+     case UNEQ_EXPR:
+     case LTGT_EXPR:
+     case PLUS_EXPR:
+     case MINUS_EXPR:
+     case MULT_EXPR:
+     case TRUNC_DIV_EXPR:
+     case CEIL_DIV_EXPR:
+     case FLOOR_DIV_EXPR:
+     case ROUND_DIV_EXPR:
+     case TRUNC_MOD_EXPR:
+     case CEIL_MOD_EXPR:
+     case FLOOR_MOD_EXPR:
+     case ROUND_MOD_EXPR:
+     case RDIV_EXPR:
+     case EXACT_DIV_EXPR:
+     case MIN_EXPR:
+     case MAX_EXPR:
+     case LSHIFT_EXPR:
+     case RSHIFT_EXPR:
+     case LROTATE_EXPR:
+     case RROTATE_EXPR:
+     case BIT_IOR_EXPR:
+     case BIT_XOR_EXPR:
+     case BIT_AND_EXPR:
+       break;
+ 
+     case CONSTRUCTOR:
+ #if 0
+       if (TREE_CONSTANT (t) && TREE_CODE (TREE_TYPE (t)) == VECTOR_TYPE);
+ #endif
+       break;
+ 
+     case TREE_LIST:
+       {
+ 	tree t1;
+ 	int prev;
+ 
+ 	prev = -1;
+ 	for (t1 = t; t1; t1 = TREE_CHAIN (t1))
+ 	  {
+ 	    if (!TREE_VALUE (t1))
+ 	      continue;
+ 
+ 	    if (prev == -1)
+ 	      fprintf (ml_fp_interf, "expr_lst_f(e%d,e%d).\n",
+ 		       expr_index, expr_nr);
+ 	    else
+ 	      fprintf (ml_fp_interf, "expr_lst_n(e%d,e%d,e%d).\n",
+ 		       expr_index, prev, expr_nr);
+ 
+ 	    prev = expr_nr;
+ 
+ 	    ml_inp_expr (TREE_VALUE (t1), expr_nr++);
+ 	  }
+ 
+       }
+       break;
+ 
+     case CALL_EXPR:
+       break;
+ 
+     default:
+       break;
+     }
+ 
+   return;
+ }
+ 
+ static void
+ ml_inp_edge (edge e, int edge_index)
+ {
+ 
+   if (e->src)
+     fprintf (ml_fp_interf, "edge_src(ed%d,bb%d).\n", 
+ 	     edge_index, e->src->index);
+ 
+   if (e->dest)
+     fprintf (ml_fp_interf, "edge_dest(ed%d,bb%d).\n", 
+ 	     edge_index, e->dest->index);
+ 
+   if (e->probability)
+     fprintf (ml_fp_interf, "edge_prob(ed%d,%.1f).\n", 
+ 	     edge_index,
+ 	     e->probability * 100.0 / REG_BR_PROB_BASE);
+ 
+   if (e->count)
+     fprintf (ml_fp_interf, "edge_count(ed%d,%d).\n", 
+ 	     edge_index, (int)e->count);
+ 
+   if (e->flags)
+     {
+       static const char * const bitnames[] = {
+ 	"fallthru", "abnormal", "abnormal_call", "eh", 
+ 	"fake", "dfs_back", "can_fallthru", "irreducible", 
+ 	"sibcall", "loop_exit",
+ 	"true", "false", "exec"
+       };
+       int i, flags = e->flags;
+ 
+       for (i = 0; flags; i++)
+ 	if (flags & (1 << i))
+ 	  {
+ 	    flags &= ~(1 << i);
+ 
+ 	    if (i < (int) ARRAY_SIZE (bitnames))
+ 	      fprintf (ml_fp_interf, "edge_flag(ed%d,%s). \n", edge_index, bitnames[i]);
+ 	  }
+     }
+ }
+ 
+ static void
+ ml_inp_bb (basic_block bb)
+ {
+   edge e;
+   edge_iterator ei;
+ 
+   fprintf (ml_fp_interf, "%% bb start\n");
+ 
+   if (bb->frequency)
+     fprintf (ml_fp_interf, "bb_freq(bb%d,%d).\n", 
+ 	     bb->index, bb->frequency);
+ 
+   if (bb->count)
+     fprintf (ml_fp_interf, "bb_count(bb%d,%d).\n", 
+ 	     bb->index, (int)bb->count);
+ 
+   FOR_EACH_EDGE (e, ei, bb->preds)
+     ml_inp_edge (e, edge_nr++);
+ 
+   fprintf (ml_fp_interf, "%% bb end\n");
+ }
+ 
+ static void
+ ml_inp_stmt (gimple stmt, int stmt_index)
+ {
+   static const char *gimple_rhs_class_name[] = {"", "binary", "unary", "single"};
+   unsigned int i;
+   
+   fprintf (ml_fp_interf, "%% stmt start\n");
+ 
+   if (is_gimple_omp (stmt))
+       return;
+ 
+   fprintf (ml_fp_interf, "stmt_code(st%d,%s).\n", stmt_index,
+            gimple_code_name [gimple_code (stmt)]);
+   fprintf (ml_fp_interf, "stmt_num_ops(st%d,%d).\n", stmt_index,
+            gimple_num_ops (stmt));
+   if (gimple_has_mem_ops (stmt))
+     fprintf (ml_fp_interf, "stmt_flag(st%d,has_mem_ops).\n", stmt_index);
+   if (gimple_has_volatile_ops (stmt))
+     fprintf (ml_fp_interf, "stmt_flag(st%d,has_volatile_ops).\n", stmt_index);
+ 
+   switch (gimple_code (stmt))
+     {
+     case GIMPLE_ASSIGN:
+       fprintf (ml_fp_interf, "assign_class(st%d,%s).\n", stmt_index, 
+                gimple_rhs_class_name [gimple_assign_rhs_class (stmt)]);
+       fprintf (ml_fp_interf, "assign_subcode(st%d,%s).\n", stmt_index, 
+ 	       tree_code_name [gimple_assign_rhs_code (stmt)]);
+       if (gimple_assign_cast_p (stmt))
+         fprintf (ml_fp_interf, "assign_flag(st%d,%s).\n", stmt_index, "cast"); /* TODO: needed? */
+       fprintf (ml_fp_interf, "assign_lhs(st%d,e%d).\n", stmt_index, expr_nr);
+       ml_inp_expr (gimple_assign_lhs (stmt), expr_nr++);
+       fprintf (ml_fp_interf, "assign_rhs1(st%d,e%d).\n", stmt_index, expr_nr);
+       ml_inp_expr (gimple_assign_rhs1 (stmt), expr_nr++);
+       if (gimple_assign_rhs_class (stmt) == GIMPLE_BINARY_RHS)
+         {
+           fprintf (ml_fp_interf, "assign_rhs2(st%d,e%d).\n", stmt_index, expr_nr);
+           ml_inp_expr (gimple_assign_rhs2 (stmt), expr_nr++);
+         }
+       break;
+ 
+     case GIMPLE_CALL:
+       fprintf (ml_fp_interf, "call_num_args(st%d,%d).\n", stmt_index,
+                gimple_call_num_args (stmt));
+       if (gimple_call_tail_p (stmt))
+         fprintf (ml_fp_interf, "call_flag(st%d,tail).\n", stmt_index);
+       if (gimple_call_noreturn_p (stmt))
+         fprintf (ml_fp_interf, "call_flag(st%d,noreturn).\n", stmt_index);
+       if (gimple_call_cannot_inline_p (stmt))
+         fprintf (ml_fp_interf, "call_flag(st%d,uninlinable).\n", stmt_index);
+       fprintf (ml_fp_interf, "call_lhs(st%d,e%d).\n", stmt_index, expr_nr);
+       ml_inp_expr (gimple_call_lhs (stmt), expr_nr++);
+       fprintf (ml_fp_interf, "call_fn(st%d,e%d).\n", stmt_index, expr_nr);
+       ml_inp_expr (gimple_call_fn (stmt), expr_nr++);
+       fprintf (ml_fp_interf, "call_treturn(st%d,e%d).\n", stmt_index, expr_nr);
+       ml_inp_expr (gimple_call_return_type (stmt), expr_nr++);
+ 
+       for (i = 0; i < gimple_call_num_args (stmt); i++)
+         {
+           fprintf (ml_fp_interf, "call_arg(st%d,e%d).\n", stmt_index, expr_nr);
+           ml_inp_expr (gimple_call_arg (stmt, i), expr_nr++);
+         }
+       break;
+ 
+     case GIMPLE_COND:
+       /* left operand */
+       fprintf (ml_fp_interf, "cond_op(st%d,e%d).\n", stmt_index, expr_nr); 
+       ml_inp_expr (gimple_cond_lhs (stmt), expr_nr++);
+       /* right operand */
+       fprintf (ml_fp_interf, "cond_op(st%d,e%d).\n", stmt_index, expr_nr);
+       ml_inp_expr (gimple_cond_rhs (stmt), expr_nr++);
+       /* labels */
+       /* TODO: should we print them? any details? */
+       fprintf (ml_fp_interf, "cond_true(st%d,e%d).\n", stmt_index, expr_nr);
+       ml_inp_expr (gimple_cond_true_label (stmt), expr_nr++);
+       fprintf (ml_fp_interf, "cond_false(st%d,e%d).\n", stmt_index, expr_nr);
+       ml_inp_expr (gimple_cond_false_label (stmt), expr_nr++);
+       break;
+ 
+     default:
+       for (i = 0; i < gimple_num_ops (stmt); i++)
+         {
+           if (gimple_op (stmt, i) != NULL_TREE)  
+             {
+               fprintf (ml_fp_interf, "stmt_op(st%d,e%d).\n",
+                        stmt_index, expr_nr);
+               ml_inp_expr (gimple_op (stmt, i), expr_nr++);
+             }
+         }
+     } /* switch */
+ 
+   /* If the statement is marked as part of an EH region, then it is
+      expected that the statement could throw.  */
+   if (lookup_stmt_eh_region (stmt) >= 0)
+     {
+ 
+     }
+ 
+   fprintf (ml_fp_interf, "%% stmt end\n");
+ }
+ 
+ static void
+ ml_inp_phi (basic_block bb)
+ {
+   int phi_num;
+   gimple phi;
+   gimple_stmt_iterator gsi;
+ 
+   fprintf (ml_fp_interf, "%% phi start\n");
+   phi_num = 0;
+   for (gsi = gsi_start (phi_nodes (bb)); !gsi_end_p (gsi); gsi_next (&gsi))
+     {
+       phi = gsi_stmt (gsi);
+       int phi_len = gimple_phi_num_args (phi);
+       int i;
+ 
+       fprintf (ml_fp_interf,"phi_bb(phi%d,bb%d). \n",
+ 	       phi_num,
+ 	       bb->index);
+       
+       fprintf (ml_fp_interf,"phi_len(phi%d,%d). \n",
+ 	       phi_num,
+ 	       phi_len);
+ 
+       fprintf (ml_fp_interf,"phi_result(phi%d,s%d). \n",
+ 	       phi_num,
+ 	       SSA_NAME_VERSION (PHI_RESULT (phi)));
+       
+       for (i = 0; i < phi_len; i++)
+ 	{
+ #if 0
+ 	  if (TREE_CODE (PHI_ARG_DEF (phi, i)) == SSA_NAME)
+ 	    {
+ 	      fprintf (ml_fp_interf,"phi_arg(phi%d,s%d). \n",
+ 		       phi_num,
+ 		       SSA_NAME_VERSION (PHI_ARG_DEF (phi, i)));
+ 	      
+ 	      fprintf (ml_fp_interf,"phi_edge(s%d,bb%d). \n",
+ 		       SSA_NAME_VERSION (PHI_ARG_DEF (phi, i)),
+ 		       PHI_ARG_EDGE (phi, i)->src->index);
+ 	    }
+ 	  else
+ 	    error ("invalid argument for a SSA_node");
+ #else
+ 	  fprintf (ml_fp_interf,"phi_arg(bb%d,e%d). \n",
+ 		   SSA_NAME_VERSION (PHI_RESULT (phi)),
+ 		   expr_nr);
+ 	  
+ 	  ml_inp_expr (PHI_ARG_DEF (phi, i), expr_nr++);
+ #endif
+ 	}
+     }
+   fprintf (ml_fp_interf, "%% phi end\n");
+ }
+ 
+ static void 
+ ml_feat_extract (void)
+ {
+   basic_block bb;
+   gimple_stmt_iterator gsi;
+ 
+   fprintf (ml_fp_interf, "%% fn start\n");
+ 
+   mls = xcalloc (1, sizeof (struct ml_state));
+   mls->var_decl_hash_table
+     = htab_create (37, key_ml_decl_node, eq_ml_decl_node, free);
+   mls->type_decl_hash_table
+     = htab_create (37, key_ml_type_node, eq_ml_type_node, free);
+ 
+   expr_nr = 0;
+   type_nr = 0;
+   var_nr = 0;
+   edge_nr = 0;
+   stmt_nr = 0;
+ 
+   fprintf (ml_fp_interf, "fn_bb_nr(fn,%d).\n", n_basic_blocks);
+   fprintf (ml_fp_interf, "fn_edge_nr(fn,%d).\n", n_edges);
+ 
+   FOR_EACH_BB (bb)
+     {
+       int prev;
+ 
+       fprintf (ml_fp_interf, "bb_p(bb%d).\n", bb->index);
+ 
+       ml_inp_bb (bb);
+ 
+       ml_inp_phi (bb);
+ 
+       prev = -1;
+       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+         {
+           gimple stmt = gsi_stmt (gsi);
+ 
+           if (prev == -1)
+             fprintf (ml_fp_interf, "bb_stmt_f(bb%d,st%d).\n",
+                      bb->index, stmt_nr);
+           else
+             fprintf (ml_fp_interf, "bb_stmt_n(bb%d,st%d,st%d).\n",
+                      bb->index, prev, stmt_nr);
+ 
+           prev = stmt_nr;
+           ml_inp_stmt (stmt, stmt_nr++);
+         }
+     }
+ 
+   htab_delete (mls->var_decl_hash_table);
+   htab_delete (mls->type_decl_hash_table);
+ 
+   VEC_free (tree, heap, mls->var_decls);
+   VEC_free (tree, heap, mls->type_decls);
+ 
+   free(mls);
+ 
+ #if 0
+   ml_history_passes ();
+ #endif
+ 
+   fprintf (ml_fp_interf, "%% fn end\n");
+ }
+ 
+ static bool
+ gate_handle_ml_feat (void)
+ {
+   return 1;
+ }
+ 
+ static unsigned int
+ rest_of_handle_ml_feat (void)
+ {
+   ml_feat_init ();
+   ml_feat_extract ();
+   ml_feat_close ();
+ 
+   return 0;
+ }
+ 
+ struct gimple_opt_pass pass_ml_feat = 
+ {
+   {
+     GIMPLE_PASS,				      /* opt_pass_type */
+     "ml-feat",			        /* name */
+     gate_handle_ml_feat,			/* gate */
+     rest_of_handle_ml_feat,		/* execute */
+     NULL,					/* sub */
+     NULL,					/* next */
+     0,					/* static_pass_number */
+     0,					/* tv_id */
+     0,	                                /* properties_required */
+     0,					/* properties_provided */
+     0,					/* properties_destroyed */
+     0,					/* todo_flags_start */
+     TODO_dump_func,
+   }
+ };
diff -crBN ../gcc-4.4.4/gcc/params.c gcc-4.4.4/gcc/params.c
*** ../gcc-4.4.4/gcc/params.c	2009-02-20 16:20:38.000000000 +0100
--- gcc-4.4.4/gcc/params.c	2010-05-05 23:12:10.000000000 +0200
***************
*** 32,39 ****
  param_info *compiler_params;
  
  /* The number of entries in the table.  */
! 
! static size_t num_compiler_params;
  
  /* Add the N PARAMS to the current list of compiler parameters.  */
  
--- 32,39 ----
  param_info *compiler_params;
  
  /* The number of entries in the table.  */
! /* Changed for FICI0: access to list of compiler parameters */
! size_t num_compiler_params;
  
  /* Add the N PARAMS to the current list of compiler parameters.  */
  
diff -crBN ../gcc-4.4.4/gcc/params.h gcc-4.4.4/gcc/params.h
*** ../gcc-4.4.4/gcc/params.h	2009-02-20 13:56:01.000000000 +0100
--- gcc-4.4.4/gcc/params.h	2010-05-05 23:12:10.000000000 +0200
***************
*** 65,70 ****
--- 65,74 ----
  
  extern param_info *compiler_params;
  
+ /* The number of entries in the table.  */
+ /* Changed for FICI0: access to list of compiler parameters */
+ extern size_t num_compiler_params;
+ 
  /* Add the N PARAMS to the current list of compiler parameters.  */
  
  extern void add_params (const param_info params[], size_t n);
diff -crBN ../gcc-4.4.4/gcc/passes.c gcc-4.4.4/gcc/passes.c
*** ../gcc-4.4.4/gcc/passes.c	2009-02-20 16:20:38.000000000 +0100
--- gcc-4.4.4/gcc/passes.c	2010-05-05 23:12:10.000000000 +0200
***************
*** 102,111 ****
--- 102,126 ----
  				   declarations for e.g. AIX 4.x.  */
  #endif
  
+ #include "highlev-plugin-internal.h"
+ #include "pass-manager.h"
+ 
  /* This is used for debugging.  It allows the current pass to printed
     from anywhere in compilation.  */
  struct opt_pass *current_pass;
  
+ 
+ /* Return current pass name if known, and NULL otherwise */
+ const char *
+ get_current_pass_name (void)
+ {
+   if (current_pass)
+     return current_pass->name;	/* can be NULL if name is not set */
+   else
+     return NULL;
+ }
+ 
+ 
  /* Call from anywhere to find out what pass this is.  Useful for
     printing out debugging information deep inside an service
     routine.  */
***************
*** 288,294 ****
  {
   {
    GIMPLE_PASS,
!   NULL,                                 /* name */
    gate_rest_of_compilation,             /* gate */
    NULL,                                 /* execute */
    NULL,                                 /* sub */
--- 303,309 ----
  {
   {
    GIMPLE_PASS,
!   "pass_rest_of_compilation",           /* name */
    gate_rest_of_compilation,             /* gate */
    NULL,                                 /* execute */
    NULL,                                 /* sub */
***************
*** 313,319 ****
  {
   {
    RTL_PASS,
!   NULL,                                 /* name */
    gate_postreload,                      /* gate */
    NULL,                                 /* execute */
    NULL,                                 /* sub */
--- 328,334 ----
  {
   {
    RTL_PASS,
!   "pass_postreload",                    /* name */
    gate_postreload,                      /* gate */
    NULL,                                 /* execute */
    NULL,                                 /* sub */
***************
*** 472,477 ****
--- 487,495 ----
        pass->todo_flags_start |= TODO_mark_first_instance;
        pass->static_pass_number = -1;
        *list = pass;
+ 
+       /* Inserts pass in ICI pass list.  */
+       register_pass (pass);
      }  
    
    return &(*list)->next;
***************
*** 1213,1224 ****
    current_pass = NULL;
  }
  
! static bool
  execute_one_pass (struct opt_pass *pass)
  {
    bool initializing_dump;
    unsigned int todo_after = 0;
  
    /* IPA passes are executed on whole program, so cfun should be NULL.
       Other passes need function context set.  */
    if (pass->type == SIMPLE_IPA_PASS || pass->type == IPA_PASS)
--- 1231,1245 ----
    current_pass = NULL;
  }
  
! bool
  execute_one_pass (struct opt_pass *pass)
  {
    bool initializing_dump;
    unsigned int todo_after = 0;
  
+   /* ICI: FGG: Important to make gate_status static to pass reference to ICI */
+   static bool gate_status;
+ 
    /* IPA passes are executed on whole program, so cfun should be NULL.
       Other passes need function context set.  */
    if (pass->type == SIMPLE_IPA_PASS || pass->type == IPA_PASS)
***************
*** 1243,1251 ****
  
    current_pass = pass;
  
!   /* See if we're supposed to run this pass.  */
!   if (pass->gate && !pass->gate ())
      return false;
  
    if (!quiet_flag && !cfun)
      fprintf (stderr, " <%s>", pass->name ? pass->name : "");
--- 1264,1286 ----
  
    current_pass = pass;
  
!   /* Check whether gate check should be avoided.  
!      User controls the value of the gate through the parameter "gate_status". */
!   gate_status = (pass->gate == NULL) ? true : pass->gate();
! 
!   register_event_parameter("gate_status", &gate_status);
!   call_plugin_event("avoid_gate");
!   unregister_event_parameter("gate_status");
! 
!   if (!gate_status) {
!     current_pass = NULL;
      return false;
+   }
+ 
+   /* Pass execution event trigger: useful to identify passes being
+      executed. Pass name is accessible as a feature (it is a constant object
+      in GCC.) */
+   call_plugin_event("pass_execution");
  
    if (!quiet_flag && !cfun)
      fprintf (stderr, " <%s>", pass->name ? pass->name : "");
diff -crBN ../gcc-4.4.4/gcc/pass-manager.c gcc-4.4.4/gcc/pass-manager.c
*** ../gcc-4.4.4/gcc/pass-manager.c	1970-01-01 01:00:00.000000000 +0100
--- gcc-4.4.4/gcc/pass-manager.c	2010-05-05 23:12:10.000000000 +0200
***************
*** 0 ****
--- 1,130 ----
+ /* High-level pass management for GCC plugins.
+    Copyright (C) 2009 Free Software Foundation, Inc.
+    
+    Contributed by Inria.
+ 
+    Authors: Grigori Fursin <gfursin@gmail.com>, Cupertino Miranda
+    <cupertinomiranda@gmail.com>, Zbigniew Chamski <zbigniew.chamski@gmail.com>.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify it under
+ the terms of the GNU General Public License as published by the Free
+ Software Foundation; either version 3, or (at your option) any later
+ version.
+ 
+ GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+ WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING3.  If not see
+ <http://www.gnu.org/licenses/>.  */
+ 
+ #include "config.h"
+ #undef FLOAT /* This is for hpux. They should change hpux.  */
+ #undef FFS  /* Some systems define this in param.h.  */
+ #include "system.h"
+ #include "coretypes.h"
+ #include "toplev.h"
+ #include "hashtab.h"
+ #include "tree-pass.h"
+ #include "highlev-plugin-internal.h"
+ #include "feature-internal.h"
+ #include "pass-manager.h"
+ 
+ static htab_t passes_hash = NULL; 
+ 
+ /* Hash table dependent functions. */
+ static hashval_t
+ passes_htab_hash (const void *x)
+ {
+   const struct opt_pass *p = (const struct opt_pass *) x;
+ 
+   if (!p)
+     internal_error ("passes_htab_hash: called with NULL pass pointer!");
+ 
+   if (p->name != NULL)
+     return htab_hash_string(p->name);
+   else
+     internal_error ("passes_htab_hash: NULL-named pass!\n");
+ }
+ 
+ static int
+ passes_htab_eq (const void *x, const void *y)
+ {
+   const struct opt_pass *p1 = (const struct opt_pass *) x;
+   const struct opt_pass *p2 = (const struct opt_pass *) y;
+ 
+   return !strcmp (p1->name, p2->name);
+ }
+ 
+ 
+ /* Accumulate pass names.  */
+ static int add_pass_name (void **slot, void *data)
+ {
+   const char ***tmp = (const char ***) data;
+   const char **list = *tmp;
+   struct opt_pass *pass = *(struct opt_pass **) slot;
+ 
+   *list = pass->name;
+ 
+   *tmp = *tmp + 1;
+   
+   return 1;
+ }
+ 
+ /* Build the array of names of all registered passes. */
+ const char **list_passes (void)
+ {
+   size_t size = htab_elements (passes_hash);
+   const char **list = 
+     (const char **) xmalloc (sizeof (const char *) * (size + 1));
+   const char ***tmp = &list;
+   const char **ret = list;
+ 
+   list[size] = NULL;
+   htab_traverse_noresize (passes_hash, add_pass_name, tmp);
+ 
+   return ret;
+ }
+ 
+ 
+ /* Insert a pass mapped by is pass_name in hash table.
+  * Allocate hash table when used for the first time.  */
+ void register_pass (struct opt_pass *pass)
+ {
+   void **slot;
+ 
+   /* Bail out if the pass has no name or an empty name */
+   if (pass->name == NULL)
+     internal_error ("Cannot register a pass with no name");
+ 
+   if (!strcmp (pass->name, ""))
+     internal_error ("Cannot register a pass with an empty name");
+ 
+   if (passes_hash == NULL)
+     passes_hash = htab_create_alloc (150, passes_htab_hash, passes_htab_eq, 
+ 				     NULL, xcalloc, free);
+ 
+   if (passes_hash == NULL)
+     error ("Could not allocate the hastable for passes");
+ 
+   slot = htab_find_slot (passes_hash, pass, INSERT);
+   *slot = pass;
+ }
+ 
+ 
+ /* Executes a pass, from any plugin, by its pass_name. */
+ void run_pass (char *pass_name)
+ {
+   struct opt_pass tmp_pass;
+   struct opt_pass *pass;
+ 
+   tmp_pass.name = pass_name;
+ 
+   pass = (struct opt_pass *) htab_find (passes_hash, &tmp_pass);
+ 
+   execute_one_pass (pass);
+ }
diff -crBN ../gcc-4.4.4/gcc/pass-manager.h gcc-4.4.4/gcc/pass-manager.h
*** ../gcc-4.4.4/gcc/pass-manager.h	1970-01-01 01:00:00.000000000 +0100
--- gcc-4.4.4/gcc/pass-manager.h	2010-05-05 23:12:10.000000000 +0200
***************
*** 0 ****
--- 1,38 ----
+ /* High-level pass management interface for plugins.
+    Copyright (C) 2009 Free Software Foundation, Inc.
+    
+    Contributed by Inria.
+ 
+    Authors: Grigori Fursin <gfursin@gmail.com>, Cupertino Miranda
+    <cupertinomiranda@gmail.com>, Zbigniew Chamski <zbigniew.chamski@gmail.com>.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify it under
+ the terms of the GNU General Public License as published by the Free
+ Software Foundation; either version 3, or (at your option) any later
+ version.
+ 
+ GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+ WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING3.  If not see
+ <http://www.gnu.org/licenses/>.  */
+ 
+ #ifndef PASS_MANAGER_H
+ #define PASS_MANAGER_H
+ 
+ /* declare the struct opt_pass type without defining it - needed to make
+    the "pointer to struct opt_pass" type unambiguous withouth pulling in
+    the complete "tree-pass.h" with its dependencies.  */
+ typedef struct opt_pass opt_pass;
+ 
+ extern const char **list_passes (void);
+ extern void register_pass (struct opt_pass *pass);
+ extern int unregister_pass (char *pass_name);
+ extern void run_pass (char *pass_name);
+ 
+ #endif /* PASS_MANAGER_H */
diff -crBN ../gcc-4.4.4/gcc/plugin-loader.c gcc-4.4.4/gcc/plugin-loader.c
*** ../gcc-4.4.4/gcc/plugin-loader.c	1970-01-01 01:00:00.000000000 +0100
--- gcc-4.4.4/gcc/plugin-loader.c	2010-05-05 23:12:10.000000000 +0200
***************
*** 0 ****
--- 1,142 ----
+ /* [Legacy] environment-based interface for loading high-level plugins.
+    Copyright (C) 2009 Free Software Foundation, Inc.
+    
+    Contributed by Inria.
+ 
+    Authors: Grigori Fursin <gfursin@gmail.com>, Cupertino Miranda
+    <cupertinomiranda@gmail.com>, Zbigniew Chamski <zbigniew.chamski@gmail.com>.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify it under
+ the terms of the GNU General Public License as published by the Free
+ Software Foundation; either version 3, or (at your option) any later
+ version.
+ 
+ GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+ WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING3.  If not see
+ <http://www.gnu.org/licenses/>.  */
+ 
+ #include "config.h"
+ #include "system.h"
+ #include "coretypes.h"
+ #include "hashtab.h"
+ #include "toplev.h"
+ #include "gcc.h"
+ #include "options.h"		/* flag_ici */
+ 
+ #include "highlev-plugin-internal.h"
+ #include "feature-internal.h"	/* init_features() */
+ 
+ #include <dlfcn.h>
+ 
+ int ici_loaded = 0;
+ 
+ /* plugin initialization/cleanup function type */
+ typedef void (*start_stop_func) (void);
+ 
+ typedef union {
+   void *data_ptr;
+   start_stop_func function_ptr;
+ } dl_symbol_t ; 
+ 
+ 
+ /* pointers to initialization/cleanup functions */
+ start_stop_func ici_plugin_start = NULL;
+ start_stop_func ici_plugin_stop = NULL;
+ 
+ 
+ /* report any errors encountered during a dl* operation */
+ static inline bool check_for_dlerror (void)
+ {
+   const char *dlError;
+   dlError = dlerror ();
+   if (dlError)
+   {
+     fprintf (stderr, "Plugin manager error: DLerror: %s ...\n", dlError);
+     return true;
+   }
+   return false;
+ }
+ 
+ 
+ /* load the ICI plugin shared library file named 'dynlib_file'.
+    Return 0 if successful, and 1 otherwise. */
+ static int 
+ load_ici_plugin_file (char *dynlib_file)
+ {
+   void  *dlhandle;
+   bool error = 0;
+   dl_symbol_t dl_symbol;
+ 
+   if (getenv ("ICI_VERBOSE") != NULL)
+     fprintf (stderr, "ICI: loading plugin ...\n");
+   
+   dlhandle = dlopen (dynlib_file, RTLD_LAZY);
+   error |= check_for_dlerror ();
+ 
+   /* assignment of data pointers to function pointers is forbidden in strict
+      ANSI mode - use a union to work around this dlsym() issue. */
+ 
+   /* plugin initialization function */
+   dl_symbol.data_ptr = dlsym (dlhandle, "start");
+   ici_plugin_start = dl_symbol.function_ptr;
+   error |= check_for_dlerror ();
+ 
+   /* plugin cleanup function */
+   dl_symbol.data_ptr = dlsym (dlhandle, "stop");
+   ici_plugin_stop = dl_symbol.function_ptr;
+   error |= check_for_dlerror ();
+ 
+   /* if init and cleanup functions are correctly resolverd, initialize the feature list */
+   if (!error)
+     init_features ();
+ 
+   return error;
+ }
+ 
+ 
+ /* load a plugin speficied by envariable ICI_PLUGIN if either -fici was
+    given on the command line or envariable ICI_USE is set to '1'. */
+ void load_ici_plugin (void)
+ {
+   char *ici_use = getenv ("ICI_USE");
+ 
+   if ((ici_use != NULL) && (ici_use[0] == '1'))
+     flag_ici = true;
+ 
+   if (flag_ici)
+     {
+       char *dynlib_file = getenv ("ICI_PLUGIN");
+       if (dynlib_file != NULL)
+ 	{
+ 	  if ((load_ici_plugin_file (dynlib_file) == 0) && ici_plugin_start)
+ 	    {
+ 	      ici_plugin_start ();
+ 	      ici_loaded = 1;
+ 	    }
+ 	}
+       else
+ 	{
+ 	  fprintf (stderr, "ICI error: Environment variable ICI_PLUGIN is not defined ...\n");
+ 	  exit (-1);
+ 	}
+     }
+ }
+ 
+ void unload_ici_plugin (void)
+ {
+   if ((ici_loaded == 1) && ici_plugin_stop)
+   {
+     ici_plugin_stop ();
+  
+     if (getenv ("ICI_VERBOSE") != NULL)
+       fprintf (stderr, "ICI: unloading plugin...\n"); 
+   }
+ }
+ 
diff -crBN ../gcc-4.4.4/gcc/predict.c gcc-4.4.4/gcc/predict.c
*** ../gcc-4.4.4/gcc/predict.c	2008-12-09 18:04:26.000000000 +0100
--- gcc-4.4.4/gcc/predict.c	2010-05-05 23:12:10.000000000 +0200
***************
*** 2218,2224 ****
  {
   {
    GIMPLE_PASS,
!   NULL,					/* name */
    NULL,					/* gate */
    strip_predict_hints,			/* execute */
    NULL,					/* sub */
--- 2218,2224 ----
  {
   {
    GIMPLE_PASS,
!   "strip_predict_hints",		/* name */
    NULL,					/* gate */
    strip_predict_hints,			/* execute */
    NULL,					/* sub */
diff -crBN ../gcc-4.4.4/gcc/reg-stack.c gcc-4.4.4/gcc/reg-stack.c
*** ../gcc-4.4.4/gcc/reg-stack.c	2009-05-22 20:59:30.000000000 +0200
--- gcc-4.4.4/gcc/reg-stack.c	2010-05-05 23:12:11.000000000 +0200
***************
*** 3223,3229 ****
  {
   {
    RTL_PASS,
!   NULL,                                 /* name */
    gate_handle_stack_regs,               /* gate */
    NULL,					/* execute */
    NULL,                                 /* sub */
--- 3223,3229 ----
  {
   {
    RTL_PASS,
!   "stack_regs",                         /* name */
    gate_handle_stack_regs,               /* gate */
    NULL,					/* execute */
    NULL,                                 /* sub */
diff -crBN ../gcc-4.4.4/gcc/stack-ptr-mod.c gcc-4.4.4/gcc/stack-ptr-mod.c
*** ../gcc-4.4.4/gcc/stack-ptr-mod.c	2009-02-20 16:20:38.000000000 +0100
--- gcc-4.4.4/gcc/stack-ptr-mod.c	2010-05-05 23:12:11.000000000 +0200
***************
*** 95,101 ****
  {
   {
    RTL_PASS,
!   NULL,		                        /* name */
    NULL,                                 /* gate */
    rest_of_handle_stack_ptr_mod,         /* execute */
    NULL,                                 /* sub */
--- 95,101 ----
  {
   {
    RTL_PASS,
!   "stack_ptr_mod",                      /* name */
    NULL,                                 /* gate */
    rest_of_handle_stack_ptr_mod,         /* execute */
    NULL,                                 /* sub */
diff -crBN ../gcc-4.4.4/gcc/toplev.c gcc-4.4.4/gcc/toplev.c
*** ../gcc-4.4.4/gcc/toplev.c	2010-03-31 04:51:31.000000000 +0200
--- gcc-4.4.4/gcc/toplev.c	2010-05-05 23:12:11.000000000 +0200
***************
*** 102,107 ****
--- 102,109 ----
  				   declarations for e.g. AIX 4.x.  */
  #endif
  
+ #include "highlev-plugin-internal.h"
+ 
  static void general_init (const char *);
  static void do_compile (void);
  static void process_options (void);
***************
*** 2222,2233 ****
--- 2224,2244 ----
       enough to default flags appropriately.  */
    decode_options (argc, argv);
  
+   /* Loads ICI plugin */
+   load_ici_plugin ();
+ 
+   /* Initialize additional passes (such as ml-feat: Static Program Features Extractor for MILEPOST GCC for example) */
+   register_pass(&pass_ml_feat);
+ 
    init_local_tick ();
  
    /* Exit early if we can (e.g. -help).  */
    if (!exit_after_options)
      do_compile ();
  
+   /* Unloads ICI plugin */
+   unload_ici_plugin ();
+ 
    if (warningcount || errorcount) 
      print_ignored_options ();
  
diff -crBN ../gcc-4.4.4/gcc/tree-cfg.c gcc-4.4.4/gcc/tree-cfg.c
*** ../gcc-4.4.4/gcc/tree-cfg.c	2009-07-02 14:16:39.000000000 +0200
--- gcc-4.4.4/gcc/tree-cfg.c	2010-05-05 23:12:11.000000000 +0200
***************
*** 7124,7130 ****
  {
   {
    GIMPLE_PASS,
!   NULL,					/* name */
    NULL,					/* gate */
    execute_warn_function_return,		/* execute */
    NULL,					/* sub */
--- 7124,7130 ----
  {
   {
    GIMPLE_PASS,
!   "warn_function_return",		/* name */
    NULL,					/* gate */
    execute_warn_function_return,		/* execute */
    NULL,					/* sub */
***************
*** 7158,7164 ****
  {
   {
    GIMPLE_PASS,
!   NULL,					/* name */
    NULL,					/* gate */
    execute_warn_function_noreturn,	/* execute */
    NULL,					/* sub */
--- 7158,7164 ----
  {
   {
    GIMPLE_PASS,
!   "warn_function_noreturn",		/* name */
    NULL,					/* gate */
    execute_warn_function_noreturn,	/* execute */
    NULL,					/* sub */
diff -crBN ../gcc-4.4.4/gcc/tree-dfa.c gcc-4.4.4/gcc/tree-dfa.c
*** ../gcc-4.4.4/gcc/tree-dfa.c	2009-03-06 23:51:28.000000000 +0100
--- gcc-4.4.4/gcc/tree-dfa.c	2010-05-05 23:12:11.000000000 +0200
***************
*** 117,123 ****
  {
   {
    GIMPLE_PASS,
!   NULL,					/* name */
    NULL,					/* gate */
    find_referenced_vars,			/* execute */
    NULL,					/* sub */
--- 117,123 ----
  {
   {
    GIMPLE_PASS,
!   "referenced_vars",			/* name */
    NULL,					/* gate */
    find_referenced_vars,			/* execute */
    NULL,					/* sub */
diff -crBN ../gcc-4.4.4/gcc/tree-eh.c gcc-4.4.4/gcc/tree-eh.c
*** ../gcc-4.4.4/gcc/tree-eh.c	2009-02-20 16:20:38.000000000 +0100
--- gcc-4.4.4/gcc/tree-eh.c	2010-05-05 23:12:11.000000000 +0200
***************
*** 1912,1918 ****
  {
   {
    GIMPLE_PASS,
!   "eh",					/* name */
    NULL,					/* gate */
    lower_eh_constructs,			/* execute */
    NULL,					/* sub */
--- 1912,1918 ----
  {
   {
    GIMPLE_PASS,
!   "lower_eh",				/* name */
    NULL,					/* gate */
    lower_eh_constructs,			/* execute */
    NULL,					/* sub */
diff -crBN ../gcc-4.4.4/gcc/tree-optimize.c gcc-4.4.4/gcc/tree-optimize.c
*** ../gcc-4.4.4/gcc/tree-optimize.c	2009-02-20 16:20:38.000000000 +0100
--- gcc-4.4.4/gcc/tree-optimize.c	2010-05-05 23:12:11.000000000 +0200
***************
*** 50,55 ****
--- 50,56 ----
  #include "cfgloop.h"
  #include "except.h"
  
+ #include "highlev-plugin-internal.h"
  
  /* Gate: execute, or not, all of the non-trivial optimizations.  */
  
***************
*** 66,72 ****
  {
   {
    GIMPLE_PASS,
!   NULL,					/* name */
    gate_all_optimizations,		/* gate */
    NULL,					/* execute */
    NULL,					/* sub */
--- 67,73 ----
  {
   {
    GIMPLE_PASS,
!   "all_optimizations",			/* name */
    gate_all_optimizations,		/* gate */
    NULL,					/* execute */
    NULL,					/* sub */
***************
*** 235,243 ****
  {
   {
    GIMPLE_PASS,
!   NULL,					/* name */
    NULL,					/* gate */
!   execute_free_datastructures,			/* execute */
    NULL,					/* sub */
    NULL,					/* next */
    0,					/* static_pass_number */
--- 236,244 ----
  {
   {
    GIMPLE_PASS,
!   "free_datastructures",		/* name */
    NULL,					/* gate */
!   execute_free_datastructures,		/* execute */
    NULL,					/* sub */
    NULL,					/* next */
    0,					/* static_pass_number */
***************
*** 264,270 ****
  {
   {
    GIMPLE_PASS,
!   NULL,					/* name */
    NULL,					/* gate */
    execute_free_cfg_annotations,		/* execute */
    NULL,					/* sub */
--- 265,271 ----
  {
   {
    GIMPLE_PASS,
!   "free_cfg_annotations",		/* name */
    NULL,					/* gate */
    execute_free_cfg_annotations,		/* execute */
    NULL,					/* sub */
***************
*** 348,354 ****
  {
   {
    GIMPLE_PASS,
!   NULL,					/* name */
    NULL,					/* gate */
    execute_init_datastructures,		/* execute */
    NULL,					/* sub */
--- 349,355 ----
  {
   {
    GIMPLE_PASS,
!   "init_datastructures",		/* name */
    NULL,					/* gate */
    execute_init_datastructures,		/* execute */
    NULL,					/* sub */
***************
*** 391,396 ****
--- 392,399 ----
  {
    location_t saved_loc;
    struct cgraph_node *node;
+   static int ici_all_passes = 0;	/* must be forced into memory for
+ 					   address-of to be meaningful */
  
    timevar_push (TV_EXPAND);
  
***************
*** 417,424 ****
  
    bitmap_obstack_initialize (&reg_obstack); /* FIXME, only at RTL generation*/
    /* Perform all tree transforms and optimizations.  */
!   execute_pass_list (all_passes);
    
    bitmap_obstack_release (&reg_obstack);
  
    /* Release the default bitmap obstack.  */
--- 420,440 ----
  
    bitmap_obstack_initialize (&reg_obstack); /* FIXME, only at RTL generation*/
    /* Perform all tree transforms and optimizations.  */
! 
!   /* ICI Event: Substitution of pass manager.
!    * ICI Parameter <all_passes> : set to identify when inside this
!    * region. It is useful when implementing <pass_execution> event 
!    * but still identify the passes from all_passes.  */
!   ici_all_passes = 1;
!   register_event_parameter ("all_passes", &ici_all_passes);
! 
!   /* try calling the event - if not successful, fall back on the default
!      pass ordering */
!   if (call_plugin_event ("all_passes_manager") != PLUGEVT_SUCCESS)
!     execute_pass_list (all_passes);
    
+   unregister_event_parameter ("all_passes");
+ 
    bitmap_obstack_release (&reg_obstack);
  
    /* Release the default bitmap obstack.  */
diff -crBN ../gcc-4.4.4/gcc/tree-pass.h gcc-4.4.4/gcc/tree-pass.h
*** ../gcc-4.4.4/gcc/tree-pass.h	2009-02-20 16:20:38.000000000 +0100
--- gcc-4.4.4/gcc/tree-pass.h	2010-05-05 23:12:11.000000000 +0200
***************
*** 389,394 ****
--- 389,397 ----
  extern struct gimple_opt_pass pass_build_cgraph_edges;
  extern struct gimple_opt_pass pass_reset_cc_flags;
  
+ /* Initialize additional passes (such as ml-feat: Static Program Features Extractor for MILEPOST GCC for example) */
+ extern struct gimple_opt_pass pass_ml_feat;
+ 
  /* IPA Passes */
  extern struct ipa_opt_pass pass_ipa_inline;
  extern struct ipa_opt_pass pass_ipa_cp;
***************
*** 519,526 ****
--- 522,531 ----
  extern struct opt_pass *current_pass;
  
  extern struct opt_pass * get_pass_for_id (int);
+ extern bool execute_one_pass (struct opt_pass *);
  extern void execute_pass_list (struct opt_pass *);
  extern void execute_ipa_pass_list (struct opt_pass *);
+ extern const char *get_current_pass_name (void);
  extern void print_current_pass (FILE *);
  extern void debug_pass (void);
  
diff -crBN ../gcc-4.4.4/gcc/tree-ssa-alias.c gcc-4.4.4/gcc/tree-ssa-alias.c
*** ../gcc-4.4.4/gcc/tree-ssa-alias.c	2010-01-05 14:41:41.000000000 +0100
--- gcc-4.4.4/gcc/tree-ssa-alias.c	2010-05-05 23:12:11.000000000 +0200
***************
*** 3766,3774 ****
  {
   {
    GIMPLE_PASS,
!   NULL,		 /* name */
!   NULL,  	 /* gate */
!   reset_cc_flags, /* execute */
    NULL,			 /* sub */
    NULL,			 /* next */
    0,			 /* static_pass_number */
--- 3766,3774 ----
  {
   {
    GIMPLE_PASS,
!   "reset_cc_flags",      /* name */
!   NULL,  	         /* gate */
!   reset_cc_flags,        /* execute */
    NULL,			 /* sub */
    NULL,			 /* next */
    0,			 /* static_pass_number */
diff -crBN ../gcc-4.4.4/gcc/tree-ssa.c gcc-4.4.4/gcc/tree-ssa.c
*** ../gcc-4.4.4/gcc/tree-ssa.c	2009-08-03 21:27:32.000000000 +0200
--- gcc-4.4.4/gcc/tree-ssa.c	2010-05-05 23:12:11.000000000 +0200
***************
*** 1643,1649 ****
  {
   {
    GIMPLE_PASS,
!   NULL,					/* name */
    gate_warn_uninitialized,		/* gate */
    execute_early_warn_uninitialized,	/* execute */
    NULL,					/* sub */
--- 1643,1649 ----
  {
   {
    GIMPLE_PASS,
!   "early_warn_uninitialized",		/* name */
    gate_warn_uninitialized,		/* gate */
    execute_early_warn_uninitialized,	/* execute */
    NULL,					/* sub */
***************
*** 1662,1668 ****
  {
   {
    GIMPLE_PASS,
!   NULL,					/* name */
    gate_warn_uninitialized,		/* gate */
    execute_late_warn_uninitialized,	/* execute */
    NULL,					/* sub */
--- 1662,1668 ----
  {
   {
    GIMPLE_PASS,
!   "late_warn_uninitialized",		/* name */
    gate_warn_uninitialized,		/* gate */
    execute_late_warn_uninitialized,	/* execute */
    NULL,					/* sub */
diff -crBN ../gcc-4.4.4/gcc/tree-ssa-loop.c gcc-4.4.4/gcc/tree-ssa-loop.c
*** ../gcc-4.4.4/gcc/tree-ssa-loop.c	2009-02-20 16:20:38.000000000 +0100
--- gcc-4.4.4/gcc/tree-ssa-loop.c	2010-05-05 23:12:11.000000000 +0200
***************
*** 481,487 ****
  {
   {
    GIMPLE_PASS,
!   NULL,					/* name */
    NULL,					/* gate */
    tree_ssa_loop_bounds,		       	/* execute */
    NULL,					/* sub */
--- 481,487 ----
  {
   {
    GIMPLE_PASS,
!   "record_bounds",			/* name */
    NULL,					/* gate */
    tree_ssa_loop_bounds,		       	/* execute */
    NULL,					/* sub */
