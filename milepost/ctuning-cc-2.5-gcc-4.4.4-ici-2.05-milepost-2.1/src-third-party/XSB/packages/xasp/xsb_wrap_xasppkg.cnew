/*
** This program has been automatically generated by the
** second-level foreign language interface of the
** XSB System
*/

#include <stdio.h>
#include <string.h>
#include "/Users/macuser/XSB/XSB/emu/cinterf.h"
#include "/Users/macuser/XSB/XSB/emu/context.h"

/* New Definition: smodelsInit from void init(CTXTdecl). */
void init(CTXTdecl );
DllExport int call_conv smodelsInit(CTXTdecl)
{
   xsb_query_save(CTXTc 0);
   init(CTXT);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up init.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsNumAtoms(a:input) from void numberAtoms(CTXTdeclc int a). */
void numberAtoms(CTXTdeclc int a);
DllExport int call_conv smodelsNumAtoms(CTXTdecl)
{
   prolog_term aIn;
   prolog_int  a;
   aIn = extern_reg_term(1);
   if (!is_int(aIn)) return FALSE;
   a = extern_p2c_int(aIn);
   xsb_query_save(CTXTc 1);
   numberAtoms(CTXTc a);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up numberAtoms.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsBeginBasicRule from void beginBasicRule(CTXTdecl). */
void beginBasicRule(CTXTdecl );
DllExport int call_conv smodelsBeginBasicRule(CTXTdecl)
{
   xsb_query_save(CTXTc 0);
   beginBasicRule(CTXT);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up beginBasicRule.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsBeginChoiceRule from void beginChoiceRule(CTXTdecl). */
void beginChoiceRule(CTXTdecl );
DllExport int call_conv smodelsBeginChoiceRule(CTXTdecl)
{
   xsb_query_save(CTXTc 0);
   beginChoiceRule(CTXT);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up beginChoiceRule.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsBeginConstraintRule from void beginConstraintRule(CTXTdecl). */
void beginConstraintRule(CTXTdecl );
DllExport int call_conv smodelsBeginConstraintRule(CTXTdecl)
{
   xsb_query_save(CTXTc 0);
   beginConstraintRule(CTXT);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up beginConstraintRule.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsBeginWeightRule from void beginWeightRule(CTXTdecl). */
void beginWeightRule(CTXTdecl );
DllExport int call_conv smodelsBeginWeightRule(CTXTdecl)
{
   xsb_query_save(CTXTc 0);
   beginWeightRule(CTXT);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up beginWeightRule.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsAddHead(a:input) from void addHead(CTXTdeclc int a). */
void addHead(CTXTdeclc int a);
DllExport int call_conv smodelsAddHead(CTXTdecl)
{
   prolog_term aIn;
   prolog_int  a;
   aIn = extern_reg_term(1);
   if (!is_int(aIn)) return FALSE;
   a = extern_p2c_int(aIn);
   xsb_query_save(CTXTc 1);
   addHead(CTXTc a);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up addHead.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsAddPosBody(a:input) from void addPosBody(CTXTdeclc int a). */
void addPosBody(CTXTdeclc int a);
DllExport int call_conv smodelsAddPosBody(CTXTdecl)
{
   prolog_term aIn;
   prolog_int  a;
   aIn = extern_reg_term(1);
   if (!is_int(aIn)) return FALSE;
   a = extern_p2c_int(aIn);
   xsb_query_save(CTXTc 1);
   addPosBody(CTXTc a);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up addPosBody.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsAddNegBody(a:input) from void addNegBody(CTXTdeclc int a). */
void addNegBody(CTXTdeclc int a);
DllExport int call_conv smodelsAddNegBody(CTXTdecl)
{
   prolog_term aIn;
   prolog_int  a;
   aIn = extern_reg_term(1);
   if (!is_int(aIn)) return FALSE;
   a = extern_p2c_int(aIn);
   xsb_query_save(CTXTc 1);
   addNegBody(CTXTc a);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up addNegBody.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsAddWPosBody(a:input,w:input) from void addWPosBody(CTXTdeclc int a,int w). */
void addWPosBody(CTXTdeclc int a, int w);
DllExport int call_conv smodelsAddWPosBody(CTXTdecl)
{
   prolog_term aIn;
   prolog_int  a;
   prolog_term wIn;
   prolog_int  w;
   aIn = extern_reg_term(1);
   if (!is_int(aIn)) return FALSE;
   a = extern_p2c_int(aIn);
   wIn = extern_reg_term(2);
   if (!is_int(wIn)) return FALSE;
   w = extern_p2c_int(wIn);
   xsb_query_save(CTXTc 2);
   addWPosBody(CTXTc a, w);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up addWPosBody.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsAddWNegBody(a:input,w:input) from void addWNegBody(CTXTdeclc int a,int w). */
void addWNegBody(CTXTdeclc int a, int w);
DllExport int call_conv smodelsAddWNegBody(CTXTdecl)
{
   prolog_term aIn;
   prolog_int  a;
   prolog_term wIn;
   prolog_int  w;
   aIn = extern_reg_term(1);
   if (!is_int(aIn)) return FALSE;
   a = extern_p2c_int(aIn);
   wIn = extern_reg_term(2);
   if (!is_int(wIn)) return FALSE;
   w = extern_p2c_int(wIn);
   xsb_query_save(CTXTc 2);
   addWNegBody(CTXTc a, w);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up addWNegBody.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsEndRule from void endRule(CTXTdecl). */
void endRule(CTXTdecl );
DllExport int call_conv smodelsEndRule(CTXTdecl)
{
   xsb_query_save(CTXTc 0);
   endRule(CTXT);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up endRule.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsCommitRules from void commitRules(CTXTdecl). */
void commitRules(CTXTdecl );
DllExport int call_conv smodelsCommitRules(CTXTdecl)
{
   xsb_query_save(CTXTc 0);
   commitRules(CTXT);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up commitRules.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsPrintProgram from void printProgram(CTXTdecl). */
void printProgram(CTXTdecl );
DllExport int call_conv smodelsPrintProgram(CTXTdecl)
{
   xsb_query_save(CTXTc 0);
   printProgram(CTXT);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up printProgram.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsExistsModel(retval:output) from int existsModel(CTXTdecl). */
int existsModel(CTXTdecl );
DllExport int call_conv smodelsExistsModel(CTXTdecl)
{
   prolog_term retvalOut;
   prolog_int retval;
   retvalOut = extern_reg_term(1);
   if(!is_var(retvalOut)) return FALSE;
   xsb_query_save(CTXTc 1);
   retval =   existsModel(CTXT);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up existsModel.\n");
      fflush(stdout);
      return FALSE;
   }
   extern_c2p_int(retval,retvalOut);
   return TRUE;
}

/* New Definition: smodelsPrintAnswer from void printAnswer(CTXTdecl). */
void printAnswer(CTXTdecl );
DllExport int call_conv smodelsPrintAnswer(CTXTdecl)
{
   xsb_query_save(CTXTc 0);
   printAnswer(CTXT);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up printAnswer.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsClose from void close(CTXTdecl). */
void close(CTXTdecl );
DllExport int call_conv smodelsClose(CTXTdecl)
{
   xsb_query_save(CTXTc 0);
   close(CTXT);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up close.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsCheckAtom(a:input,retval:output) from int checkAtom(CTXTdeclc int a). */
int checkAtom(CTXTdeclc int a);
DllExport int call_conv smodelsCheckAtom(CTXTdecl)
{
   prolog_term aIn;
   prolog_int  a;
   prolog_term retvalOut;
   prolog_int retval;
   aIn = extern_reg_term(1);
   if (!is_int(aIn)) return FALSE;
   a = extern_p2c_int(aIn);
   retvalOut = extern_reg_term(2);
   if(!is_var(retvalOut)) return FALSE;
   xsb_query_save(CTXTc 2);
   retval =   checkAtom(CTXTc a);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up checkAtom.\n");
      fflush(stdout);
      return FALSE;
   }
   extern_c2p_int(retval,retvalOut);
   return TRUE;
}

/* New Definition: smodelsSetPosCompute(a:input) from void setPosCompute(CTXTdeclc int a). */
void setPosCompute(CTXTdeclc int a);
DllExport int call_conv smodelsSetPosCompute(CTXTdecl)
{
   prolog_term aIn;
   prolog_int  a;
   aIn = extern_reg_term(1);
   if (!is_int(aIn)) return FALSE;
   a = extern_p2c_int(aIn);
   xsb_query_save(CTXTc 1);
   setPosCompute(CTXTc a);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up setPosCompute.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsSetNegCompute(a:input) from void setNegCompute(CTXTdeclc int a). */
void setNegCompute(CTXTdeclc int a);
DllExport int call_conv smodelsSetNegCompute(CTXTdecl)
{
   prolog_term aIn;
   prolog_int  a;
   aIn = extern_reg_term(1);
   if (!is_int(aIn)) return FALSE;
   a = extern_p2c_int(aIn);
   xsb_query_save(CTXTc 1);
   setNegCompute(CTXTc a);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up setNegCompute.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsResetPosCompute(a:input) from void resetPosCompute(CTXTdeclc int a). */
void resetPosCompute(CTXTdeclc int a);
DllExport int call_conv smodelsResetPosCompute(CTXTdecl)
{
   prolog_term aIn;
   prolog_int  a;
   aIn = extern_reg_term(1);
   if (!is_int(aIn)) return FALSE;
   a = extern_p2c_int(aIn);
   xsb_query_save(CTXTc 1);
   resetPosCompute(CTXTc a);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up resetPosCompute.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsResetNegCompute(a:input) from void resetNegCompute(CTXTdeclc int a). */
void resetNegCompute(CTXTdeclc int a);
DllExport int call_conv smodelsResetNegCompute(CTXTdecl)
{
   prolog_term aIn;
   prolog_int  a;
   aIn = extern_reg_term(1);
   if (!is_int(aIn)) return FALSE;
   a = extern_p2c_int(aIn);
   xsb_query_save(CTXTc 1);
   resetNegCompute(CTXTc a);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up resetNegCompute.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsRemember from void remember(CTXTdecl). */
void remember(CTXTdecl );
DllExport int call_conv smodelsRemember(CTXTdecl)
{
   xsb_query_save(CTXTc 0);
   remember(CTXT);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up remember.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsForget from void forget(CTXTdecl). */
void forget(CTXTdecl );
DllExport int call_conv smodelsForget(CTXTdecl)
{
   xsb_query_save(CTXTc 0);
   forget(CTXT);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up forget.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsSetBody(a:input) from void setBody(CTXTdeclc int a). */
void setBody(CTXTdeclc int a);
DllExport int call_conv smodelsSetBody(CTXTdecl)
{
   prolog_term aIn;
   prolog_int  a;
   aIn = extern_reg_term(1);
   if (!is_int(aIn)) return FALSE;
   a = extern_p2c_int(aIn);
   xsb_query_save(CTXTc 1);
   setBody(CTXTc a);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up setBody.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsSetWeight(a:input) from void setWeight(CTXTdeclc int a). */
void setWeight(CTXTdeclc int a);
DllExport int call_conv smodelsSetWeight(CTXTdecl)
{
   prolog_term aIn;
   prolog_int  a;
   aIn = extern_reg_term(1);
   if (!is_int(aIn)) return FALSE;
   a = extern_p2c_int(aIn);
   xsb_query_save(CTXTc 1);
   setWeight(CTXTc a);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up setWeight.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsSetHead(a:input) from void setHead(CTXTdeclc int a). */
void setHead(CTXTdeclc int a);
DllExport int call_conv smodelsSetHead(CTXTdecl)
{
   prolog_term aIn;
   prolog_int  a;
   aIn = extern_reg_term(1);
   if (!is_int(aIn)) return FALSE;
   a = extern_p2c_int(aIn);
   xsb_query_save(CTXTc 1);
   setHead(CTXTc a);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up setHead.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsWellFounded from void wellfounded(CTXTdecl). */
void wellfounded(CTXTdecl );
DllExport int call_conv smodelsWellFounded(CTXTdecl)
{
   xsb_query_save(CTXTc 0);
   wellfounded(CTXT);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up wellfounded.\n");
      fflush(stdout);
      return FALSE;
   }
   return TRUE;
}

/* New Definition: smodelsTestPos(a:input,retval:output) from int testPos(CTXTdeclc int a). */
int testPos(CTXTdeclc int a);
DllExport int call_conv smodelsTestPos(CTXTdecl)
{
   prolog_term aIn;
   prolog_int  a;
   prolog_term retvalOut;
   prolog_int retval;
   aIn = extern_reg_term(1);
   if (!is_int(aIn)) return FALSE;
   a = extern_p2c_int(aIn);
   retvalOut = extern_reg_term(2);
   if(!is_var(retvalOut)) return FALSE;
   xsb_query_save(CTXTc 2);
   retval =   testPos(CTXTc a);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up testPos.\n");
      fflush(stdout);
      return FALSE;
   }
   extern_c2p_int(retval,retvalOut);
   return TRUE;
}

/* New Definition: smodelsTestNeg(a:input,retval:output) from int testNeg(CTXTdeclc int a). */
int testNeg(CTXTdeclc int a);
DllExport int call_conv smodelsTestNeg(CTXTdecl)
{
   prolog_term aIn;
   prolog_int  a;
   prolog_term retvalOut;
   prolog_int retval;
   aIn = extern_reg_term(1);
   if (!is_int(aIn)) return FALSE;
   a = extern_p2c_int(aIn);
   retvalOut = extern_reg_term(2);
   if(!is_var(retvalOut)) return FALSE;
   xsb_query_save(CTXTc 2);
   retval =   testNeg(CTXTc a);
   if (xsb_query_restore(CTXT)) {  // restore regs to prepare for exit
      printf("Error finishing up testNeg.\n");
      fflush(stdout);
      return FALSE;
   }
   extern_c2p_int(retval,retvalOut);
   return TRUE;
}

