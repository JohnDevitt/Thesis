

@node The XSB Assertion Library, next,  previous,  up
@comment node-name, next,  previous,  up
@chapter The XSB Assertion Library
@c -------------------------------------------------
@c WARNING: Do not edit this file (assertions_props.texic)
@c It has been generated automatically from file:  
@c assertions_props.P
@c -------------------------------------------------


This module is under development and is subject to change. Assertions in this style will be documented by xsbdoc, but no type checking is done yet by the compiler. 

The 
@glindex assertions
@code{assertions} module has many of the same goals of the CIAO assertions package, but is much simpler in syntax. Currently all assertions (apart from machine readible comments) are specified via the compiler directive 


@smallexample 
    :- pred HeadPattern :: AssertionBody.
    @end smallexample  

where @code{head_pattern(HeadPattern)} and @code{AssertionBody} are both true. The idea is that each such declaration defines a 
@glindex usage
usage of a predicate -- a call pattern and an associated success pattern. The exact syntax is described in documentation for the predicates 
@glindex head_pattern/1
@code{head_pattern/1} and 
@glindex assertion_body/1
@code{assertion_body/1}. 

Such patterns are certainly useful for documentation, and 
@glindex xsbdoc
@code{xsbdoc} is includes these patterns in the documentation it generates (see @ref{Introduction} for information on how to contol formatting of such documentation). However, such information can also be useful for compilation tools, such as a run-time test generator (under development) or static analysis. 





@node Usage and interface (assertions_props), next,  previous,  up
@comment node-name, next,  previous,  up
@section Usage and interface (@code{assertions_props})
@cartouche
@itemize @bullet{}

@item @strong{Exports:}
@itemize @minus


@item @emph{Predicates:}

@glindex assertion_body/1
@code{assertion_body/1}, 
@glindex head_pattern/1
@code{head_pattern/1}, 
@glindex assrt_status/1
@code{assrt_status/1}.


@end itemize

@end itemize
@end cartouche


@node Documentation on exports (assertions_props), next,  previous,  up
@comment node-name, next,  previous,  up
@section Documentation on exports (@code{assertions_props})
@pdindex assertion_body/1 
@glindex assertion_body/1 
@deffn PREDICATE assertion_body/1:



This predicate succeeds if its argument is true. In XSB, assertion bodies are much simpler than in Ciao. An assertion body is a list of up to 5 terms. These are: 
@itemize @bullet{} 


@item @code{call_prop(Comma_list)} which contains a comma list of predicates which are true of given arguments when the predicate is called for a given usage of a predicate to be true. 


@item @code{success_prop(Comma_list)} which contains a comma list of predicates which must be true of given arguments when the predicate succedes for this usage. 


@item @code{global_prop(Comma_list)} which contains a comma list of predicates which must be true of given arguments at any point during an execution. 


@item @code{compat_prop(Comma_list)} which contains a comma list of predicates which must be true for this usage that do not fit into one of the other properties, for instance that the this usage of the predicate does not fail. 


@item @code{comment(Docstring)} which contains a string of type 
@glindex docstring/1
@code{docstring/1} which describes this usage. 


@end itemize  

An example is of an assertion body occurs in the following predicate: 


@smallexample 
     :- pred foo(X,Y) :: 
         [call_prop((nonvar(X),var(Y))),
          success_prop((ground(X),ground(Y)))]
   @end smallexample  



@end deffn
@sp 1

@pdindex head_pattern/1 
@glindex head_pattern/1 
@deffn PREDICATE head_pattern/1:



A 
@glindex head pattern
head pattern can be a predicate name (functor/arity) (
@glindex predname/1
@code{predname/1}) or a term. Thus, both @code{p/3} and @code{p(A,B,C)} are valid head patterns. In the case in which the head pattern is a term, each argument of such a term can be: 


@itemize @bullet{} 


@item A variable. This is useful in order to be able to refer to the corresponding argument positions by name within properties and in comments. Thus, @code{p(Input,Parameter,Output)} is a valid head pattern. 


@item A term. In this case, the fact that a given argument unifies with a particular term is a global property of the usage. An example is the pattern 
@smallexample 
   comment(module,Docstring)
   @end smallexample  
which indicates that the first argument is always unifiable with the atom @code{module}. 


@end itemize  





@end deffn
@sp 1

@pdindex assrt_status/1 
@glindex assrt_status/1 
@deffn PREDICATE assrt_status/1:



The types of assertion status. They have the same meaning as the program-point assertions, and are as follows: 
@smallexample 
assrt_status(trust) .

assrt_status(checked) .

assrt_status(check) .

assrt_status(false) .

assrt_status(true) .

@end smallexample 
. TLS No checking is yet implemented in XSB.

@end deffn
@sp 1

